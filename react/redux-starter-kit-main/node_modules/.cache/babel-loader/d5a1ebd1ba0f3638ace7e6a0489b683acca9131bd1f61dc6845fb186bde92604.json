{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Headers: () => HeadersPolyfill,\n  flattenHeadersList: () => flattenHeadersList,\n  flattenHeadersObject: () => flattenHeadersObject,\n  headersToList: () => headersToList,\n  headersToObject: () => headersToObject,\n  headersToString: () => headersToString,\n  listToHeaders: () => listToHeaders,\n  objectToHeaders: () => objectToHeaders,\n  reduceHeadersObject: () => reduceHeadersObject,\n  stringToHeaders: () => stringToHeaders\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/utils/normalizeHeaderName.ts\nvar HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i;\nfunction normalizeHeaderName(name) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === \"\") {\n    throw new TypeError(\"Invalid character in header field name\");\n  }\n  return name.toLowerCase();\n}\n\n// src/utils/normalizeHeaderValue.ts\nfunction normalizeHeaderValue(value) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\n\n// src/Headers.ts\nvar NORMALIZED_HEADERS = Symbol(\"normalizedHeaders\");\nvar RAW_HEADER_NAMES = Symbol(\"rawHeaderNames\");\nvar _a, _b;\nvar HeadersPolyfill = class {\n  constructor(init) {\n    this[_a] = {};\n    this[_b] = /* @__PURE__ */new Map();\n    if ([\"Headers\", \"HeadersPolyfill\"].includes(init == null ? void 0 : init.constructor.name) || init instanceof HeadersPolyfill) {\n      const initialHeaders = init;\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(init)) {\n      init.forEach(_ref => {\n        let [name, value] = _ref;\n        this.append(name, Array.isArray(value) ? value.join(\", \") : value);\n      });\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach(name => {\n        const value = init[name];\n        this.append(name, Array.isArray(value) ? value.join(\", \") : value);\n      });\n    }\n  }\n  [(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, Symbol.iterator)]() {\n    return this.entries();\n  }\n  *keys() {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield name;\n    }\n  }\n  *values() {\n    for (const value of Object.values(this[NORMALIZED_HEADERS])) {\n      yield value;\n    }\n  }\n  *entries() {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield [name, this.get(name)];\n    }\n  }\n  get(name) {\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] || null;\n  }\n  set(name, value) {\n    const normalizedName = normalizeHeaderName(name);\n    this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(value);\n    this[RAW_HEADER_NAMES].set(normalizedName, name);\n  }\n  append(name, value) {\n    const normalizedName = normalizeHeaderName(name);\n    let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${value}` : value;\n    this.set(name, resolvedValue);\n  }\n  delete(name) {\n    if (!this.has(name)) {\n      return;\n    }\n    const normalizedName = normalizeHeaderName(name);\n    delete this[NORMALIZED_HEADERS][normalizedName];\n    this[RAW_HEADER_NAMES].delete(normalizedName);\n  }\n  all() {\n    return this[NORMALIZED_HEADERS];\n  }\n  raw() {\n    const rawHeaders = {};\n    for (const [name, value] of this.entries()) {\n      rawHeaders[this[RAW_HEADER_NAMES].get(name)] = value;\n    }\n    return rawHeaders;\n  }\n  has(name) {\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));\n  }\n  forEach(callback, thisArg) {\n    for (const name in this[NORMALIZED_HEADERS]) {\n      if (this[NORMALIZED_HEADERS].hasOwnProperty(name)) {\n        callback.call(thisArg, this[NORMALIZED_HEADERS][name], name, this);\n      }\n    }\n  }\n};\n\n// src/transformers/headersToList.ts\nfunction headersToList(headers) {\n  const headersList = [];\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(\",\") ? value.split(\",\").map(value2 => value2.trim()) : value;\n    headersList.push([name, resolvedValue]);\n  });\n  return headersList;\n}\n\n// src/transformers/headersToString.ts\nfunction headersToString(headers) {\n  const list = headersToList(headers);\n  const lines = list.map(_ref2 => {\n    let [name, value] = _ref2;\n    const values = [].concat(value);\n    return `${name}: ${values.join(\", \")}`;\n  });\n  return lines.join(\"\\r\\n\");\n}\n\n// src/transformers/headersToObject.ts\nvar singleValueHeaders = [\"user-agent\"];\nfunction headersToObject(headers) {\n  const headersObject = {};\n  headers.forEach((value, name) => {\n    const isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(\",\");\n    headersObject[name] = isMultiValue ? value.split(\",\").map(s => s.trim()) : value;\n  });\n  return headersObject;\n}\n\n// src/transformers/stringToHeaders.ts\nfunction stringToHeaders(str) {\n  const lines = str.trim().split(/[\\r\\n]+/);\n  return lines.reduce((headers, line) => {\n    if (line.trim() === \"\") {\n      return headers;\n    }\n    const parts = line.split(\": \");\n    const name = parts.shift();\n    const value = parts.join(\": \");\n    headers.append(name, value);\n    return headers;\n  }, new HeadersPolyfill());\n}\n\n// src/transformers/listToHeaders.ts\nfunction listToHeaders(list) {\n  const headers = new HeadersPolyfill();\n  list.forEach(_ref3 => {\n    let [name, value] = _ref3;\n    const values = [].concat(value);\n    values.forEach(value2 => {\n      headers.append(name, value2);\n    });\n  });\n  return headers;\n}\n\n// src/transformers/reduceHeadersObject.ts\nfunction reduceHeadersObject(headers, reducer, initialState) {\n  return Object.keys(headers).reduce((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name]);\n  }, initialState);\n}\n\n// src/transformers/objectToHeaders.ts\nfunction objectToHeaders(headersObject) {\n  return reduceHeadersObject(headersObject, (headers, name, value) => {\n    const values = [].concat(value).filter(Boolean);\n    values.forEach(value2 => {\n      headers.append(name, value2);\n    });\n    return headers;\n  }, new HeadersPolyfill());\n}\n\n// src/transformers/flattenHeadersList.ts\nfunction flattenHeadersList(list) {\n  return list.map(_ref4 => {\n    let [name, values] = _ref4;\n    return [name, [].concat(values).join(\", \")];\n  });\n}\n\n// src/transformers/flattenHeadersObject.ts\nfunction flattenHeadersObject(headersObject) {\n  return reduceHeadersObject(headersObject, (headers, name, value) => {\n    headers[name] = [].concat(value).join(\", \");\n    return headers;\n  }, {});\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  Headers,\n  flattenHeadersList,\n  flattenHeadersObject,\n  headersToList,\n  headersToObject,\n  headersToString,\n  listToHeaders,\n  objectToHeaders,\n  reduceHeadersObject,\n  stringToHeaders\n});\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}