{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.store = exports.PERSISTENCY_KEY = void 0;\nconst set_cookie_parser_1 = require(\"set-cookie-parser\");\nexports.PERSISTENCY_KEY = 'MSW_COOKIE_STORE';\nfunction supportsLocalStorage() {\n  try {\n    if (localStorage == null) {\n      return false;\n    }\n    const testKey = exports.PERSISTENCY_KEY + '_test';\n    localStorage.setItem(testKey, 'test');\n    localStorage.getItem(testKey);\n    localStorage.removeItem(testKey);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nclass CookieStore {\n  constructor() {\n    this.store = new Map();\n  }\n  /**\n   * Sets the given request cookies into the store.\n   * Respects the `request.credentials` policy.\n   */\n  add(request, response) {\n    if (request.credentials === 'omit') {\n      return;\n    }\n    const requestUrl = new URL(request.url);\n    const responseCookies = response.headers.get('set-cookie');\n    if (!responseCookies) {\n      return;\n    }\n    const now = Date.now();\n    const parsedResponseCookies = set_cookie_parser_1.parse(responseCookies).map(_a => {\n      var {\n          maxAge\n        } = _a,\n        cookie = __rest(_a, [\"maxAge\"]);\n      return Object.assign(Object.assign({}, cookie), {\n        expires: maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000),\n        maxAge\n      });\n    });\n    const prevCookies = this.store.get(requestUrl.origin) || new Map();\n    parsedResponseCookies.forEach(cookie => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie));\n    });\n  }\n  /**\n   * Returns cookies relevant to the given request\n   * and its `request.credentials` policy.\n   */\n  get(request) {\n    this.deleteExpiredCookies();\n    const requestUrl = new URL(request.url);\n    const originCookies = this.store.get(requestUrl.origin) || new Map();\n    switch (request.credentials) {\n      case 'include':\n        {\n          // Support running this method in Node.js.\n          if (typeof document === 'undefined') {\n            return originCookies;\n          }\n          const documentCookies = set_cookie_parser_1.parse(document.cookie);\n          documentCookies.forEach(cookie => {\n            originCookies.set(cookie.name, cookie);\n          });\n          return originCookies;\n        }\n      case 'same-origin':\n        {\n          return originCookies;\n        }\n      default:\n        return new Map();\n    }\n  }\n  /**\n   * Returns a collection of all stored cookies.\n   */\n  getAll() {\n    this.deleteExpiredCookies();\n    return this.store;\n  }\n  /**\n   * Deletes all cookies associated with the given request.\n   */\n  deleteAll(request) {\n    const requestUrl = new URL(request.url);\n    this.store.delete(requestUrl.origin);\n  }\n  /**\n   * Clears the entire cookie store.\n   */\n  clear() {\n    this.store.clear();\n  }\n  /**\n   * Hydrates the virtual cookie store from the `localStorage` if defined.\n   */\n  hydrate() {\n    if (!supportsLocalStorage()) {\n      return;\n    }\n    const persistedCookies = localStorage.getItem(exports.PERSISTENCY_KEY);\n    if (!persistedCookies) {\n      return;\n    }\n    try {\n      const parsedCookies = JSON.parse(persistedCookies);\n      parsedCookies.forEach(_ref => {\n        let [origin, cookies] = _ref;\n        this.store.set(origin, new Map(cookies.map(_a => {\n          var [token, _b] = _a,\n            {\n              expires\n            } = _b,\n            cookie = __rest(_b, [\"expires\"]);\n          return [token, expires === undefined ? cookie : Object.assign(Object.assign({}, cookie), {\n            expires: new Date(expires)\n          })];\n        })));\n      });\n    } catch (error) {\n      console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${exports.PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(exports.PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`);\n      localStorage.removeItem(exports.PERSISTENCY_KEY);\n    }\n  }\n  /**\n   * Persists the current virtual cookies into the `localStorage` if defined,\n   * so they are available on the next page load.\n   */\n  persist() {\n    if (!supportsLocalStorage()) {\n      return;\n    }\n    const serializedCookies = Array.from(this.store.entries()).map(_ref2 => {\n      let [origin, cookies] = _ref2;\n      return [origin, Array.from(cookies.entries())];\n    });\n    localStorage.setItem(exports.PERSISTENCY_KEY, JSON.stringify(serializedCookies));\n  }\n  deleteExpiredCookies() {\n    const now = Date.now();\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(_ref3 => {\n        let {\n          expires,\n          name\n        } = _ref3;\n        if (expires !== undefined && expires.getTime() <= now) {\n          originCookies.delete(name);\n        }\n      });\n      if (originCookies.size === 0) {\n        this.store.delete(origin);\n      }\n    });\n  }\n}\nexports.store = new CookieStore();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}