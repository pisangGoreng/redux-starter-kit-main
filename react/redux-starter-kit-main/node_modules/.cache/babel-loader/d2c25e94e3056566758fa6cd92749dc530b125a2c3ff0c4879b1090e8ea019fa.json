{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.Mock = global.Mock || {});\n})(this, function (exports) {\n  'use strict';\n\n  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  /**\n   * Check if we're required to add a port number.\n   *\n   * @see https://url.spec.whatwg.org/#default-port\n   * @param {Number|String} port Port number we need to check\n   * @param {String} protocol Protocol we need to check against.\n   * @returns {Boolean} Is it a default port for the given protocol\n   * @api private\n   */\n  var requiresPort = function required(port, protocol) {\n    protocol = protocol.split(':')[0];\n    port = +port;\n    if (!port) {\n      return false;\n    }\n    switch (protocol) {\n      case 'http':\n      case 'ws':\n        return port !== 80;\n      case 'https':\n      case 'wss':\n        return port !== 443;\n      case 'ftp':\n        return port !== 21;\n      case 'gopher':\n        return port !== 70;\n      case 'file':\n        return false;\n    }\n    return port !== 0;\n  };\n  var has = Object.prototype.hasOwnProperty;\n  var undef;\n\n  /**\n   * Decode a URI encoded string.\n   *\n   * @param {String} input The URI encoded string.\n   * @returns {String|Null} The decoded string.\n   * @api private\n   */\n  function decode(input) {\n    try {\n      return decodeURIComponent(input.replace(/\\+/g, ' '));\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Attempts to encode a given input.\n   *\n   * @param {String} input The string that needs to be encoded.\n   * @returns {String|Null} The encoded string.\n   * @api private\n   */\n  function encode(input) {\n    try {\n      return encodeURIComponent(input);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Simple query string parser.\n   *\n   * @param {String} query The query string that needs to be parsed.\n   * @returns {Object}\n   * @api public\n   */\n  function querystring(query) {\n    var parser = /([^=?#&]+)=?([^&]*)/g,\n      result = {},\n      part;\n    while (part = parser.exec(query)) {\n      var key = decode(part[1]),\n        value = decode(part[2]);\n\n      //\n      // Prevent overriding of existing properties. This ensures that build-in\n      // methods like `toString` or __proto__ are not overriden by malicious\n      // querystrings.\n      //\n      // In the case if failed decoding, we want to omit the key/value pairs\n      // from the result.\n      //\n      if (key === null || value === null || key in result) {\n        continue;\n      }\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * Transform a query string to an object.\n   *\n   * @param {Object} obj Object that should be transformed.\n   * @param {String} prefix Optional prefix.\n   * @returns {String}\n   * @api public\n   */\n  function querystringify(obj, prefix) {\n    prefix = prefix || '';\n    var pairs = [],\n      value,\n      key;\n\n    //\n    // Optionally prefix with a '?' if needed\n    //\n    if ('string' !== typeof prefix) {\n      prefix = '?';\n    }\n    for (key in obj) {\n      if (has.call(obj, key)) {\n        value = obj[key];\n\n        //\n        // Edge cases where we actually want to encode the value to an empty\n        // string instead of the stringified value.\n        //\n        if (!value && (value === null || value === undef || isNaN(value))) {\n          value = '';\n        }\n        key = encode(key);\n        value = encode(value);\n\n        //\n        // If we failed to encode the strings, we should bail out as we don't\n        // want to add invalid strings to the query.\n        //\n        if (key === null || value === null) {\n          continue;\n        }\n        pairs.push(key + '=' + value);\n      }\n    }\n    return pairs.length ? prefix + pairs.join('&') : '';\n  }\n\n  //\n  // Expose the module.\n  //\n  var stringify = querystringify;\n  var parse = querystring;\n  var querystringify_1 = {\n    stringify: stringify,\n    parse: parse\n  };\n  var CRHTLF = /[\\n\\r\\t]/g;\n  var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n  var protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i;\n  var windowsDriveLetter = /^[a-zA-Z]:/;\n  var whitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n\n  /**\n   * Trim a given string.\n   *\n   * @param {String} str String to trim.\n   * @public\n   */\n  function trimLeft(str) {\n    return (str ? str : '').toString().replace(whitespace, '');\n  }\n\n  /**\n   * These are the parse rules for the URL parser, it informs the parser\n   * about:\n   *\n   * 0. The char it Needs to parse, if it's a string it should be done using\n   *    indexOf, RegExp using exec and NaN means set as current value.\n   * 1. The property we should set when parsing this value.\n   * 2. Indication if it's backwards or forward parsing, when set as number it's\n   *    the value of extra chars that should be split off.\n   * 3. Inherit from location if non existing in the parser.\n   * 4. `toLowerCase` the resulting value.\n   */\n  var rules = [['#', 'hash'],\n  // Extract from the back.\n  ['?', 'query'],\n  // Extract from the back.\n  function sanitize(address, url) {\n    // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  }, ['/', 'pathname'],\n  // Extract from the back.\n  ['@', 'auth', 1],\n  // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],\n  // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],\n  // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1] // Set left over.\n  ];\n\n  /**\n   * These properties should not be copied or inherited from. This is only needed\n   * for all non blob URL's as a blob URL does not include a hash, only the\n   * origin.\n   *\n   * @type {Object}\n   * @private\n   */\n  var ignore = {\n    hash: 1,\n    query: 1\n  };\n\n  /**\n   * The location object differs when your code is loaded through a normal page,\n   * Worker or through a worker using a blob. And with the blobble begins the\n   * trouble as the location object will contain the URL of the blob, not the\n   * location of the page where our code is loaded in. The actual origin is\n   * encoded in the `pathname` so we can thankfully generate a good \"default\"\n   * location from it so we can generate proper relative URL's again.\n   *\n   * @param {Object|String} loc Optional default location object.\n   * @returns {Object} lolcation object.\n   * @public\n   */\n  function lolcation(loc) {\n    var globalVar;\n    if (typeof window !== 'undefined') {\n      globalVar = window;\n    } else if (typeof commonjsGlobal !== 'undefined') {\n      globalVar = commonjsGlobal;\n    } else if (typeof self !== 'undefined') {\n      globalVar = self;\n    } else {\n      globalVar = {};\n    }\n    var location = globalVar.location || {};\n    loc = loc || location;\n    var finaldestination = {},\n      type = typeof loc,\n      key;\n    if ('blob:' === loc.protocol) {\n      finaldestination = new Url(unescape(loc.pathname), {});\n    } else if ('string' === type) {\n      finaldestination = new Url(loc, {});\n      for (key in ignore) {\n        delete finaldestination[key];\n      }\n    } else if ('object' === type) {\n      for (key in loc) {\n        if (key in ignore) {\n          continue;\n        }\n        finaldestination[key] = loc[key];\n      }\n      if (finaldestination.slashes === undefined) {\n        finaldestination.slashes = slashes.test(loc.href);\n      }\n    }\n    return finaldestination;\n  }\n\n  /**\n   * Check whether a protocol scheme is special.\n   *\n   * @param {String} The protocol scheme of the URL\n   * @return {Boolean} `true` if the protocol scheme is special, else `false`\n   * @private\n   */\n  function isSpecial(scheme) {\n    return scheme === 'file:' || scheme === 'ftp:' || scheme === 'http:' || scheme === 'https:' || scheme === 'ws:' || scheme === 'wss:';\n  }\n\n  /**\n   * @typedef ProtocolExtract\n   * @type Object\n   * @property {String} protocol Protocol matched in the URL, in lowercase.\n   * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n   * @property {String} rest Rest of the URL that is not part of the protocol.\n   */\n\n  /**\n   * Extract protocol information from a URL with/without double slash (\"//\").\n   *\n   * @param {String} address URL we want to extract from.\n   * @param {Object} location\n   * @return {ProtocolExtract} Extracted information.\n   * @private\n   */\n  function extractProtocol(address, location) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, '');\n    location = location || {};\n    var match = protocolre.exec(address);\n    var protocol = match[1] ? match[1].toLowerCase() : '';\n    var forwardSlashes = !!match[2];\n    var otherSlashes = !!match[3];\n    var slashesCount = 0;\n    var rest;\n    if (forwardSlashes) {\n      if (otherSlashes) {\n        rest = match[2] + match[3] + match[4];\n        slashesCount = match[2].length + match[3].length;\n      } else {\n        rest = match[2] + match[4];\n        slashesCount = match[2].length;\n      }\n    } else {\n      if (otherSlashes) {\n        rest = match[3] + match[4];\n        slashesCount = match[3].length;\n      } else {\n        rest = match[4];\n      }\n    }\n    if (protocol === 'file:') {\n      if (slashesCount >= 2) {\n        rest = rest.slice(2);\n      }\n    } else if (isSpecial(protocol)) {\n      rest = match[4];\n    } else if (protocol) {\n      if (forwardSlashes) {\n        rest = rest.slice(2);\n      }\n    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n      rest = match[4];\n    }\n    return {\n      protocol: protocol,\n      slashes: forwardSlashes || isSpecial(protocol),\n      slashesCount: slashesCount,\n      rest: rest\n    };\n  }\n\n  /**\n   * Resolve a relative URL pathname against a base URL pathname.\n   *\n   * @param {String} relative Pathname of the relative URL.\n   * @param {String} base Pathname of the base URL.\n   * @return {String} Resolved pathname.\n   * @private\n   */\n  function resolve(relative, base) {\n    if (relative === '') {\n      return base;\n    }\n    var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),\n      i = path.length,\n      last = path[i - 1],\n      unshift = false,\n      up = 0;\n    while (i--) {\n      if (path[i] === '.') {\n        path.splice(i, 1);\n      } else if (path[i] === '..') {\n        path.splice(i, 1);\n        up++;\n      } else if (up) {\n        if (i === 0) {\n          unshift = true;\n        }\n        path.splice(i, 1);\n        up--;\n      }\n    }\n    if (unshift) {\n      path.unshift('');\n    }\n    if (last === '.' || last === '..') {\n      path.push('');\n    }\n    return path.join('/');\n  }\n\n  /**\n   * The actual URL instance. Instead of returning an object we've opted-in to\n   * create an actual constructor as it's much more memory efficient and\n   * faster and it pleases my OCD.\n   *\n   * It is worth noting that we should not use `URL` as class name to prevent\n   * clashes with the global URL instance that got introduced in browsers.\n   *\n   * @constructor\n   * @param {String} address URL we want to parse.\n   * @param {Object|String} [location] Location defaults for relative paths.\n   * @param {Boolean|Function} [parser] Parser for the query string.\n   * @private\n   */\n  function Url(address, location, parser) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, '');\n    if (!(this instanceof Url)) {\n      return new Url(address, location, parser);\n    }\n    var relative,\n      extracted,\n      parse,\n      instruction,\n      index,\n      key,\n      instructions = rules.slice(),\n      type = typeof location,\n      url = this,\n      i = 0;\n\n    //\n    // The following if statements allows this module two have compatibility with\n    // 2 different API:\n    //\n    // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n    //    where the boolean indicates that the query string should also be parsed.\n    //\n    // 2. The `URL` interface of the browser which accepts a URL, object as\n    //    arguments. The supplied object will be used as default values / fall-back\n    //    for relative paths.\n    //\n    if ('object' !== type && 'string' !== type) {\n      parser = location;\n      location = null;\n    }\n    if (parser && 'function' !== typeof parser) {\n      parser = querystringify_1.parse;\n    }\n    location = lolcation(location);\n\n    //\n    // Extract protocol information before running the instructions.\n    //\n    extracted = extractProtocol(address || '', location);\n    relative = !extracted.protocol && !extracted.slashes;\n    url.slashes = extracted.slashes || relative && location.slashes;\n    url.protocol = extracted.protocol || location.protocol || '';\n    address = extracted.rest;\n\n    //\n    // When the authority component is absent the URL starts with a path\n    // component.\n    //\n    if (extracted.protocol === 'file:' && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {\n      instructions[3] = [/(.*)/, 'pathname'];\n    }\n    for (; i < instructions.length; i++) {\n      instruction = instructions[i];\n      if (typeof instruction === 'function') {\n        address = instruction(address, url);\n        continue;\n      }\n      parse = instruction[0];\n      key = instruction[1];\n      if (parse !== parse) {\n        url[key] = address;\n      } else if ('string' === typeof parse) {\n        index = parse === '@' ? address.lastIndexOf(parse) : address.indexOf(parse);\n        if (~index) {\n          if ('number' === typeof instruction[2]) {\n            url[key] = address.slice(0, index);\n            address = address.slice(index + instruction[2]);\n          } else {\n            url[key] = address.slice(index);\n            address = address.slice(0, index);\n          }\n        }\n      } else if (index = parse.exec(address)) {\n        url[key] = index[1];\n        address = address.slice(0, index.index);\n      }\n      url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');\n\n      //\n      // Hostname, host and protocol should be lowercased so they can be used to\n      // create a proper `origin`.\n      //\n      if (instruction[4]) {\n        url[key] = url[key].toLowerCase();\n      }\n    }\n\n    //\n    // Also parse the supplied query string in to an object. If we're supplied\n    // with a custom parser as function use that instead of the default build-in\n    // parser.\n    //\n    if (parser) {\n      url.query = parser(url.query);\n    }\n\n    //\n    // If the URL is relative, resolve the pathname against the base URL.\n    //\n    if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {\n      url.pathname = resolve(url.pathname, location.pathname);\n    }\n\n    //\n    // Default to a / for pathname if none exists. This normalizes the URL\n    // to always have a /\n    //\n    if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n      url.pathname = '/' + url.pathname;\n    }\n\n    //\n    // We should not add port numbers if they are already the default port number\n    // for a given protocol. As the host also contains the port number we're going\n    // override it with the hostname which contains no port number.\n    //\n    if (!requiresPort(url.port, url.protocol)) {\n      url.host = url.hostname;\n      url.port = '';\n    }\n\n    //\n    // Parse down the `auth` for the username and password.\n    //\n    url.username = url.password = '';\n    if (url.auth) {\n      index = url.auth.indexOf(':');\n      if (~index) {\n        url.username = url.auth.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n        url.password = url.auth.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(url.auth));\n      }\n      url.auth = url.password ? url.username + ':' + url.password : url.username;\n    }\n    url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';\n\n    //\n    // The href is just the compiled result.\n    //\n    url.href = url.toString();\n  }\n\n  /**\n   * This is convenience method for changing properties in the URL instance to\n   * insure that they all propagate correctly.\n   *\n   * @param {String} part          Property we need to adjust.\n   * @param {Mixed} value          The newly assigned value.\n   * @param {Boolean|Function} fn  When setting the query, it will be the function\n   *                               used to parse the query.\n   *                               When setting the protocol, double slash will be\n   *                               removed from the final url if it is true.\n   * @returns {URL} URL instance for chaining.\n   * @public\n   */\n  function set(part, value, fn) {\n    var url = this;\n    switch (part) {\n      case 'query':\n        if ('string' === typeof value && value.length) {\n          value = (fn || querystringify_1.parse)(value);\n        }\n        url[part] = value;\n        break;\n      case 'port':\n        url[part] = value;\n        if (!requiresPort(value, url.protocol)) {\n          url.host = url.hostname;\n          url[part] = '';\n        } else if (value) {\n          url.host = url.hostname + ':' + value;\n        }\n        break;\n      case 'hostname':\n        url[part] = value;\n        if (url.port) {\n          value += ':' + url.port;\n        }\n        url.host = value;\n        break;\n      case 'host':\n        url[part] = value;\n        if (/:\\d+$/.test(value)) {\n          value = value.split(':');\n          url.port = value.pop();\n          url.hostname = value.join(':');\n        } else {\n          url.hostname = value;\n          url.port = '';\n        }\n        break;\n      case 'protocol':\n        url.protocol = value.toLowerCase();\n        url.slashes = !fn;\n        break;\n      case 'pathname':\n      case 'hash':\n        if (value) {\n          var char = part === 'pathname' ? '/' : '#';\n          url[part] = value.charAt(0) !== char ? char + value : value;\n        } else {\n          url[part] = value;\n        }\n        break;\n      case 'username':\n      case 'password':\n        url[part] = encodeURIComponent(value);\n        break;\n      case 'auth':\n        var index = value.indexOf(':');\n        if (~index) {\n          url.username = value.slice(0, index);\n          url.username = encodeURIComponent(decodeURIComponent(url.username));\n          url.password = value.slice(index + 1);\n          url.password = encodeURIComponent(decodeURIComponent(url.password));\n        } else {\n          url.username = encodeURIComponent(decodeURIComponent(value));\n        }\n    }\n    for (var i = 0; i < rules.length; i++) {\n      var ins = rules[i];\n      if (ins[4]) {\n        url[ins[1]] = url[ins[1]].toLowerCase();\n      }\n    }\n    url.auth = url.password ? url.username + ':' + url.password : url.username;\n    url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';\n    url.href = url.toString();\n    return url;\n  }\n\n  /**\n   * Transform the properties back in to a valid and full URL string.\n   *\n   * @param {Function} stringify Optional query stringify function.\n   * @returns {String} Compiled version of the URL.\n   * @public\n   */\n  function toString(stringify) {\n    if (!stringify || 'function' !== typeof stringify) {\n      stringify = querystringify_1.stringify;\n    }\n    var query,\n      url = this,\n      host = url.host,\n      protocol = url.protocol;\n    if (protocol && protocol.charAt(protocol.length - 1) !== ':') {\n      protocol += ':';\n    }\n    var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? '//' : '');\n    if (url.username) {\n      result += url.username;\n      if (url.password) {\n        result += ':' + url.password;\n      }\n      result += '@';\n    } else if (url.password) {\n      result += ':' + url.password;\n      result += '@';\n    } else if (url.protocol !== 'file:' && isSpecial(url.protocol) && !host && url.pathname !== '/') {\n      //\n      // Add back the empty userinfo, otherwise the original invalid URL\n      // might be transformed into a valid one with `url.pathname` as host.\n      //\n      result += '@';\n    }\n\n    //\n    // Trailing colon is removed from `url.host` when it is parsed. If it still\n    // ends with a colon, then add back the trailing colon that was removed. This\n    // prevents an invalid URL from being transformed into a valid one.\n    //\n    if (host[host.length - 1] === ':') {\n      host += ':';\n    }\n    result += host + url.pathname;\n    query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n    if (query) {\n      result += '?' !== query.charAt(0) ? '?' + query : query;\n    }\n    if (url.hash) {\n      result += url.hash;\n    }\n    return result;\n  }\n  Url.prototype = {\n    set: set,\n    toString: toString\n  };\n\n  //\n  // Expose the URL parser and some additional properties that might be useful for\n  // others or testing.\n  //\n  Url.extractProtocol = extractProtocol;\n  Url.location = lolcation;\n  Url.trimLeft = trimLeft;\n  Url.qs = querystringify_1;\n  var urlParse = Url;\n\n  /*\n   * This delay allows the thread to finish assigning its on* methods\n   * before invoking the delay callback. This is purely a timing hack.\n   * http://geekabyte.blogspot.com/2014/01/javascript-effect-of-setting-settimeout.html\n   *\n   * @param {callback: function} the callback which will be invoked after the timeout\n   * @parma {context: object} the context in which to invoke the function\n   */\n  function delay(callback, context) {\n    setTimeout(function (timeoutContext) {\n      return callback.call(timeoutContext);\n    }, 4, context);\n  }\n  function log(method, message) {\n    /* eslint-disable no-console */\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n      console[method].call(null, message);\n    }\n    /* eslint-enable no-console */\n  }\n\n  function reject(array, callback) {\n    if (array === void 0) array = [];\n    var results = [];\n    array.forEach(function (itemInArray) {\n      if (!callback(itemInArray)) {\n        results.push(itemInArray);\n      }\n    });\n    return results;\n  }\n  function filter(array, callback) {\n    if (array === void 0) array = [];\n    var results = [];\n    array.forEach(function (itemInArray) {\n      if (callback(itemInArray)) {\n        results.push(itemInArray);\n      }\n    });\n    return results;\n  }\n\n  /*\n   * EventTarget is an interface implemented by objects that can\n   * receive events and may have listeners for them.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n   */\n  var EventTarget = function EventTarget() {\n    this.listeners = {};\n  };\n\n  /*\n   * Ties a listener function to an event type which can later be invoked via the\n   * dispatchEvent method.\n   *\n   * @param {string} type - the type of event (ie: 'open', 'message', etc.)\n   * @param {function} listener - callback function to invoke when an event is dispatched matching the type\n   * @param {boolean} useCapture - N/A TODO: implement useCapture functionality\n   */\n  EventTarget.prototype.addEventListener = function addEventListener(type, listener /* , useCapture */) {\n    if (typeof listener === 'function') {\n      if (!Array.isArray(this.listeners[type])) {\n        this.listeners[type] = [];\n      }\n\n      // Only add the same function once\n      if (filter(this.listeners[type], function (item) {\n        return item === listener;\n      }).length === 0) {\n        this.listeners[type].push(listener);\n      }\n    }\n  };\n\n  /*\n   * Removes the listener so it will no longer be invoked via the dispatchEvent method.\n   *\n   * @param {string} type - the type of event (ie: 'open', 'message', etc.)\n   * @param {function} listener - callback function to invoke when an event is dispatched matching the type\n   * @param {boolean} useCapture - N/A TODO: implement useCapture functionality\n   */\n  EventTarget.prototype.removeEventListener = function removeEventListener(type, removingListener /* , useCapture */) {\n    var arrayOfListeners = this.listeners[type];\n    this.listeners[type] = reject(arrayOfListeners, function (listener) {\n      return listener === removingListener;\n    });\n  };\n\n  /*\n   * Invokes all listener functions that are listening to the given event.type property. Each\n   * listener will be passed the event as the first argument.\n   *\n   * @param {object} event - event object which will be passed to all listeners of the event.type property\n   */\n  EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n    var this$1 = this;\n    var customArguments = [],\n      len = arguments.length - 1;\n    while (len-- > 0) customArguments[len] = arguments[len + 1];\n    var eventName = event.type;\n    var listeners = this.listeners[eventName];\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n    listeners.forEach(function (listener) {\n      if (customArguments.length > 0) {\n        listener.apply(this$1, customArguments);\n      } else {\n        listener.call(this$1, event);\n      }\n    });\n    return true;\n  };\n  function trimQueryPartFromURL(url) {\n    var queryIndex = url.indexOf('?');\n    return queryIndex >= 0 ? url.slice(0, queryIndex) : url;\n  }\n\n  /*\n   * The network bridge is a way for the mock websocket object to 'communicate' with\n   * all available servers. This is a singleton object so it is important that you\n   * clean up urlMap whenever you are finished.\n   */\n  var NetworkBridge = function NetworkBridge() {\n    this.urlMap = {};\n  };\n\n  /*\n   * Attaches a websocket object to the urlMap hash so that it can find the server\n   * it is connected to and the server in turn can find it.\n   *\n   * @param {object} websocket - websocket object to add to the urlMap hash\n   * @param {string} url\n   */\n  NetworkBridge.prototype.attachWebSocket = function attachWebSocket(websocket, url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) === -1) {\n      connectionLookup.websockets.push(websocket);\n      return connectionLookup.server;\n    }\n  };\n\n  /*\n   * Attaches a websocket to a room\n   */\n  NetworkBridge.prototype.addMembershipToRoom = function addMembershipToRoom(websocket, room) {\n    var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n    if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) !== -1) {\n      if (!connectionLookup.roomMemberships[room]) {\n        connectionLookup.roomMemberships[room] = [];\n      }\n      connectionLookup.roomMemberships[room].push(websocket);\n    }\n  };\n\n  /*\n   * Attaches a server object to the urlMap hash so that it can find a websockets\n   * which are connected to it and so that websockets can in turn can find it.\n   *\n   * @param {object} server - server object to add to the urlMap hash\n   * @param {string} url\n   */\n  NetworkBridge.prototype.attachServer = function attachServer(server, url) {\n    var serverUrl = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverUrl];\n    if (!connectionLookup) {\n      this.urlMap[serverUrl] = {\n        server: server,\n        websockets: [],\n        roomMemberships: {}\n      };\n      return server;\n    }\n  };\n\n  /*\n   * Finds the server which is 'running' on the given url.\n   *\n   * @param {string} url - the url to use to find which server is running on it\n   */\n  NetworkBridge.prototype.serverLookup = function serverLookup(url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup) {\n      return connectionLookup.server;\n    }\n  };\n\n  /*\n   * Finds all websockets which is 'listening' on the given url.\n   *\n   * @param {string} url - the url to use to find all websockets which are associated with it\n   * @param {string} room - if a room is provided, will only return sockets in this room\n   * @param {class} broadcaster - socket that is broadcasting and is to be excluded from the lookup\n   */\n  NetworkBridge.prototype.websocketsLookup = function websocketsLookup(url, room, broadcaster) {\n    var serverURL = trimQueryPartFromURL(url);\n    var websockets;\n    var connectionLookup = this.urlMap[serverURL];\n    websockets = connectionLookup ? connectionLookup.websockets : [];\n    if (room) {\n      var members = connectionLookup.roomMemberships[room];\n      websockets = members || [];\n    }\n    return broadcaster ? websockets.filter(function (websocket) {\n      return websocket !== broadcaster;\n    }) : websockets;\n  };\n\n  /*\n   * Removes the entry associated with the url.\n   *\n   * @param {string} url\n   */\n  NetworkBridge.prototype.removeServer = function removeServer(url) {\n    delete this.urlMap[trimQueryPartFromURL(url)];\n  };\n\n  /*\n   * Removes the individual websocket from the map of associated websockets.\n   *\n   * @param {object} websocket - websocket object to remove from the url map\n   * @param {string} url\n   */\n  NetworkBridge.prototype.removeWebSocket = function removeWebSocket(websocket, url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup) {\n      connectionLookup.websockets = reject(connectionLookup.websockets, function (socket) {\n        return socket === websocket;\n      });\n    }\n  };\n\n  /*\n   * Removes a websocket from a room\n   */\n  NetworkBridge.prototype.removeMembershipFromRoom = function removeMembershipFromRoom(websocket, room) {\n    var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n    var memberships = connectionLookup.roomMemberships[room];\n    if (connectionLookup && memberships !== null) {\n      connectionLookup.roomMemberships[room] = reject(memberships, function (socket) {\n        return socket === websocket;\n      });\n    }\n  };\n  var networkBridge = new NetworkBridge(); // Note: this is a singleton\n\n  /*\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n   */\n  var CLOSE_CODES = {\n    CLOSE_NORMAL: 1000,\n    CLOSE_GOING_AWAY: 1001,\n    CLOSE_PROTOCOL_ERROR: 1002,\n    CLOSE_UNSUPPORTED: 1003,\n    CLOSE_NO_STATUS: 1005,\n    CLOSE_ABNORMAL: 1006,\n    UNSUPPORTED_DATA: 1007,\n    POLICY_VIOLATION: 1008,\n    CLOSE_TOO_LARGE: 1009,\n    MISSING_EXTENSION: 1010,\n    INTERNAL_ERROR: 1011,\n    SERVICE_RESTART: 1012,\n    TRY_AGAIN_LATER: 1013,\n    TLS_HANDSHAKE: 1015\n  };\n  var ERROR_PREFIX = {\n    CONSTRUCTOR_ERROR: \"Failed to construct 'WebSocket':\",\n    CLOSE_ERROR: \"Failed to execute 'close' on 'WebSocket':\",\n    EVENT: {\n      CONSTRUCT: \"Failed to construct 'Event':\",\n      MESSAGE: \"Failed to construct 'MessageEvent':\",\n      CLOSE: \"Failed to construct 'CloseEvent':\"\n    }\n  };\n  var EventPrototype = function EventPrototype() {};\n  EventPrototype.prototype.stopPropagation = function stopPropagation() {};\n  EventPrototype.prototype.stopImmediatePropagation = function stopImmediatePropagation() {};\n\n  // if no arguments are passed then the type is set to \"undefined\" on\n  // chrome and safari.\n  EventPrototype.prototype.initEvent = function initEvent(type, bubbles, cancelable) {\n    if (type === void 0) type = 'undefined';\n    if (bubbles === void 0) bubbles = false;\n    if (cancelable === void 0) cancelable = false;\n    this.type = \"\" + type;\n    this.bubbles = Boolean(bubbles);\n    this.cancelable = Boolean(cancelable);\n  };\n  var Event = function (EventPrototype$$1) {\n    function Event(type, eventInitConfig) {\n      if (eventInitConfig === void 0) eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT_ERROR + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== 'object') {\n        throw new TypeError(ERROR_PREFIX.EVENT_ERROR + \" parameter 2 ('eventInitDict') is not an object.\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.cancelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n    }\n    if (EventPrototype$$1) Event.__proto__ = EventPrototype$$1;\n    Event.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    Event.prototype.constructor = Event;\n    return Event;\n  }(EventPrototype);\n  var MessageEvent = function (EventPrototype$$1) {\n    function MessageEvent(type, eventInitConfig) {\n      if (eventInitConfig === void 0) eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== 'object') {\n        throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + \" parameter 2 ('eventInitDict') is not an object\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      var data = eventInitConfig.data;\n      var origin = eventInitConfig.origin;\n      var lastEventId = eventInitConfig.lastEventId;\n      var ports = eventInitConfig.ports;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.canncelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n      this.origin = \"\" + origin;\n      this.ports = typeof ports === 'undefined' ? null : ports;\n      this.data = typeof data === 'undefined' ? null : data;\n      this.lastEventId = \"\" + (lastEventId || '');\n    }\n    if (EventPrototype$$1) MessageEvent.__proto__ = EventPrototype$$1;\n    MessageEvent.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    MessageEvent.prototype.constructor = MessageEvent;\n    return MessageEvent;\n  }(EventPrototype);\n  var CloseEvent = function (EventPrototype$$1) {\n    function CloseEvent(type, eventInitConfig) {\n      if (eventInitConfig === void 0) eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== 'object') {\n        throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + \" parameter 2 ('eventInitDict') is not an object\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      var code = eventInitConfig.code;\n      var reason = eventInitConfig.reason;\n      var wasClean = eventInitConfig.wasClean;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.cancelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n      this.code = typeof code === 'number' ? parseInt(code, 10) : 0;\n      this.reason = \"\" + (reason || '');\n      this.wasClean = wasClean ? Boolean(wasClean) : false;\n    }\n    if (EventPrototype$$1) CloseEvent.__proto__ = EventPrototype$$1;\n    CloseEvent.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    CloseEvent.prototype.constructor = CloseEvent;\n    return CloseEvent;\n  }(EventPrototype);\n\n  /*\n   * Creates an Event object and extends it to allow full modification of\n   * its properties.\n   *\n   * @param {object} config - within config you will need to pass type and optionally target\n   */\n  function createEvent(config) {\n    var type = config.type;\n    var target = config.target;\n    var eventObject = new Event(type);\n    if (target) {\n      eventObject.target = target;\n      eventObject.srcElement = target;\n      eventObject.currentTarget = target;\n    }\n    return eventObject;\n  }\n\n  /*\n   * Creates a MessageEvent object and extends it to allow full modification of\n   * its properties.\n   *\n   * @param {object} config - within config: type, origin, data and optionally target\n   */\n  function createMessageEvent(config) {\n    var type = config.type;\n    var origin = config.origin;\n    var data = config.data;\n    var target = config.target;\n    var messageEvent = new MessageEvent(type, {\n      data: data,\n      origin: origin\n    });\n    if (target) {\n      messageEvent.target = target;\n      messageEvent.srcElement = target;\n      messageEvent.currentTarget = target;\n    }\n    return messageEvent;\n  }\n\n  /*\n   * Creates a CloseEvent object and extends it to allow full modification of\n   * its properties.\n   *\n   * @param {object} config - within config: type and optionally target, code, and reason\n   */\n  function createCloseEvent(config) {\n    var code = config.code;\n    var reason = config.reason;\n    var type = config.type;\n    var target = config.target;\n    var wasClean = config.wasClean;\n    if (!wasClean) {\n      wasClean = code === CLOSE_CODES.CLOSE_NORMAL || code === CLOSE_CODES.CLOSE_NO_STATUS;\n    }\n    var closeEvent = new CloseEvent(type, {\n      code: code,\n      reason: reason,\n      wasClean: wasClean\n    });\n    if (target) {\n      closeEvent.target = target;\n      closeEvent.srcElement = target;\n      closeEvent.currentTarget = target;\n    }\n    return closeEvent;\n  }\n  function closeWebSocketConnection(context, code, reason) {\n    context.readyState = WebSocket$1.CLOSING;\n    var server = networkBridge.serverLookup(context.url);\n    var closeEvent = createCloseEvent({\n      type: 'close',\n      target: context.target,\n      code: code,\n      reason: reason\n    });\n    delay(function () {\n      networkBridge.removeWebSocket(context, context.url);\n      context.readyState = WebSocket$1.CLOSED;\n      context.dispatchEvent(closeEvent);\n      if (server) {\n        server.dispatchEvent(closeEvent, server);\n      }\n    }, context);\n  }\n  function failWebSocketConnection(context, code, reason) {\n    context.readyState = WebSocket$1.CLOSING;\n    var server = networkBridge.serverLookup(context.url);\n    var closeEvent = createCloseEvent({\n      type: 'close',\n      target: context.target,\n      code: code,\n      reason: reason,\n      wasClean: false\n    });\n    var errorEvent = createEvent({\n      type: 'error',\n      target: context.target\n    });\n    delay(function () {\n      networkBridge.removeWebSocket(context, context.url);\n      context.readyState = WebSocket$1.CLOSED;\n      context.dispatchEvent(errorEvent);\n      context.dispatchEvent(closeEvent);\n      if (server) {\n        server.dispatchEvent(closeEvent, server);\n      }\n    }, context);\n  }\n  function normalizeSendData(data) {\n    if (Object.prototype.toString.call(data) !== '[object Blob]' && !(data instanceof ArrayBuffer)) {\n      data = String(data);\n    }\n    return data;\n  }\n  var proxies = new WeakMap();\n  function proxyFactory(target) {\n    if (proxies.has(target)) {\n      return proxies.get(target);\n    }\n    var proxy = new Proxy(target, {\n      get: function get(obj, prop) {\n        if (prop === 'close') {\n          return function close(options) {\n            if (options === void 0) options = {};\n            var code = options.code || CLOSE_CODES.CLOSE_NORMAL;\n            var reason = options.reason || '';\n            closeWebSocketConnection(proxy, code, reason);\n          };\n        }\n        if (prop === 'send') {\n          return function send(data) {\n            data = normalizeSendData(data);\n            target.dispatchEvent(createMessageEvent({\n              type: 'message',\n              data: data,\n              origin: this.url,\n              target: target\n            }));\n          };\n        }\n        var toSocketName = function (type) {\n          return type === 'message' ? \"server::\" + type : type;\n        };\n        if (prop === 'on') {\n          return function onWrapper(type, cb) {\n            target.addEventListener(toSocketName(type), cb);\n          };\n        }\n        if (prop === 'off') {\n          return function offWrapper(type, cb) {\n            target.removeEventListener(toSocketName(type), cb);\n          };\n        }\n        if (prop === 'target') {\n          return target;\n        }\n        return obj[prop];\n      }\n    });\n    proxies.set(target, proxy);\n    return proxy;\n  }\n  function lengthInUtf8Bytes(str) {\n    // Matches only the 10.. bytes that are non-initial characters in a multi-byte sequence.\n    var m = encodeURIComponent(str).match(/%[89ABab]/g);\n    return str.length + (m ? m.length : 0);\n  }\n  function urlVerification(url) {\n    var urlRecord = new urlParse(url);\n    var pathname = urlRecord.pathname;\n    var protocol = urlRecord.protocol;\n    var hash = urlRecord.hash;\n    if (!url) {\n      throw new TypeError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" 1 argument required, but only 0 present.\");\n    }\n    if (!pathname) {\n      urlRecord.pathname = '/';\n    }\n    if (protocol === '') {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL '\" + urlRecord.toString() + \"' is invalid.\");\n    }\n    if (protocol !== 'ws:' && protocol !== 'wss:') {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL's scheme must be either 'ws' or 'wss'. '\" + protocol + \"' is not allowed.\");\n    }\n    if (hash !== '') {\n      /* eslint-disable max-len */\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL contains a fragment identifier ('\" + hash + \"'). Fragment identifiers are not allowed in WebSocket URLs.\");\n      /* eslint-enable max-len */\n    }\n\n    return urlRecord.toString();\n  }\n  function protocolVerification(protocols) {\n    if (protocols === void 0) protocols = [];\n    if (!Array.isArray(protocols) && typeof protocols !== 'string') {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The subprotocol '\" + protocols.toString() + \"' is invalid.\");\n    }\n    if (typeof protocols === 'string') {\n      protocols = [protocols];\n    }\n    var uniq = protocols.map(function (p) {\n      return {\n        count: 1,\n        protocol: p\n      };\n    }).reduce(function (a, b) {\n      a[b.protocol] = (a[b.protocol] || 0) + b.count;\n      return a;\n    }, {});\n    var duplicates = Object.keys(uniq).filter(function (a) {\n      return uniq[a] > 1;\n    });\n    if (duplicates.length > 0) {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The subprotocol '\" + duplicates[0] + \"' is duplicated.\");\n    }\n    return protocols;\n  }\n\n  /*\n   * The main websocket class which is designed to mimick the native WebSocket class as close\n   * as possible.\n   *\n   * https://html.spec.whatwg.org/multipage/web-sockets.html\n   */\n  var WebSocket$1 = function (EventTarget$$1) {\n    function WebSocket(url, protocols) {\n      EventTarget$$1.call(this);\n      this._onopen = null;\n      this._onmessage = null;\n      this._onerror = null;\n      this._onclose = null;\n      this.url = urlVerification(url);\n      protocols = protocolVerification(protocols);\n      this.protocol = protocols[0] || '';\n      this.binaryType = 'blob';\n      this.readyState = WebSocket.CONNECTING;\n      var client = proxyFactory(this);\n      var server = networkBridge.attachWebSocket(client, this.url);\n\n      /*\n       * This delay is needed so that we dont trigger an event before the callbacks have been\n       * setup. For example:\n       *\n       * var socket = new WebSocket('ws://localhost');\n       *\n       * If we dont have the delay then the event would be triggered right here and this is\n       * before the onopen had a chance to register itself.\n       *\n       * socket.onopen = () => { // this would never be called };\n       *\n       * and with the delay the event gets triggered here after all of the callbacks have been\n       * registered :-)\n       */\n      delay(function delayCallback() {\n        if (server) {\n          if (server.options.verifyClient && typeof server.options.verifyClient === 'function' && !server.options.verifyClient()) {\n            this.readyState = WebSocket.CLOSED;\n            log('error', \"WebSocket connection to '\" + this.url + \"' failed: HTTP Authentication failed; no valid credentials available\");\n            networkBridge.removeWebSocket(client, this.url);\n            this.dispatchEvent(createEvent({\n              type: 'error',\n              target: this\n            }));\n            this.dispatchEvent(createCloseEvent({\n              type: 'close',\n              target: this,\n              code: CLOSE_CODES.CLOSE_NORMAL\n            }));\n          } else {\n            if (server.options.selectProtocol && typeof server.options.selectProtocol === 'function') {\n              var selectedProtocol = server.options.selectProtocol(protocols);\n              var isFilled = selectedProtocol !== '';\n              var isRequested = protocols.indexOf(selectedProtocol) !== -1;\n              if (isFilled && !isRequested) {\n                this.readyState = WebSocket.CLOSED;\n                log('error', \"WebSocket connection to '\" + this.url + \"' failed: Invalid Sub-Protocol\");\n                networkBridge.removeWebSocket(client, this.url);\n                this.dispatchEvent(createEvent({\n                  type: 'error',\n                  target: this\n                }));\n                this.dispatchEvent(createCloseEvent({\n                  type: 'close',\n                  target: this,\n                  code: CLOSE_CODES.CLOSE_NORMAL\n                }));\n                return;\n              }\n              this.protocol = selectedProtocol;\n            }\n            this.readyState = WebSocket.OPEN;\n            this.dispatchEvent(createEvent({\n              type: 'open',\n              target: this\n            }));\n            server.dispatchEvent(createEvent({\n              type: 'connection'\n            }), client);\n          }\n        } else {\n          this.readyState = WebSocket.CLOSED;\n          this.dispatchEvent(createEvent({\n            type: 'error',\n            target: this\n          }));\n          this.dispatchEvent(createCloseEvent({\n            type: 'close',\n            target: this,\n            code: CLOSE_CODES.CLOSE_NORMAL\n          }));\n          log('error', \"WebSocket connection to '\" + this.url + \"' failed\");\n        }\n      }, this);\n    }\n    if (EventTarget$$1) WebSocket.__proto__ = EventTarget$$1;\n    WebSocket.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    WebSocket.prototype.constructor = WebSocket;\n    var prototypeAccessors = {\n      onopen: {},\n      onmessage: {},\n      onclose: {},\n      onerror: {}\n    };\n    prototypeAccessors.onopen.get = function () {\n      return this._onopen;\n    };\n    prototypeAccessors.onmessage.get = function () {\n      return this._onmessage;\n    };\n    prototypeAccessors.onclose.get = function () {\n      return this._onclose;\n    };\n    prototypeAccessors.onerror.get = function () {\n      return this._onerror;\n    };\n    prototypeAccessors.onopen.set = function (listener) {\n      this.removeEventListener('open', this._onopen);\n      this._onopen = listener;\n      this.addEventListener('open', listener);\n    };\n    prototypeAccessors.onmessage.set = function (listener) {\n      this.removeEventListener('message', this._onmessage);\n      this._onmessage = listener;\n      this.addEventListener('message', listener);\n    };\n    prototypeAccessors.onclose.set = function (listener) {\n      this.removeEventListener('close', this._onclose);\n      this._onclose = listener;\n      this.addEventListener('close', listener);\n    };\n    prototypeAccessors.onerror.set = function (listener) {\n      this.removeEventListener('error', this._onerror);\n      this._onerror = listener;\n      this.addEventListener('error', listener);\n    };\n    WebSocket.prototype.send = function send(data) {\n      var this$1 = this;\n      if (this.readyState === WebSocket.CLOSING || this.readyState === WebSocket.CLOSED) {\n        throw new Error('WebSocket is already in CLOSING or CLOSED state');\n      }\n\n      // TODO: handle bufferedAmount\n\n      var messageEvent = createMessageEvent({\n        type: 'server::message',\n        origin: this.url,\n        data: normalizeSendData(data)\n      });\n      var server = networkBridge.serverLookup(this.url);\n      if (server) {\n        delay(function () {\n          this$1.dispatchEvent(messageEvent, data);\n        }, server);\n      }\n    };\n    WebSocket.prototype.close = function close(code, reason) {\n      if (code !== undefined) {\n        if (typeof code !== 'number' || code !== 1000 && (code < 3000 || code > 4999)) {\n          throw new TypeError(ERROR_PREFIX.CLOSE_ERROR + \" The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\");\n        }\n      }\n      if (reason !== undefined) {\n        var length = lengthInUtf8Bytes(reason);\n        if (length > 123) {\n          throw new SyntaxError(ERROR_PREFIX.CLOSE_ERROR + \" The message must not be greater than 123 bytes.\");\n        }\n      }\n      if (this.readyState === WebSocket.CLOSING || this.readyState === WebSocket.CLOSED) {\n        return;\n      }\n      var client = proxyFactory(this);\n      if (this.readyState === WebSocket.CONNECTING) {\n        failWebSocketConnection(client, code || CLOSE_CODES.CLOSE_ABNORMAL, reason);\n      } else {\n        closeWebSocketConnection(client, code || CLOSE_CODES.CLOSE_NO_STATUS, reason);\n      }\n    };\n    Object.defineProperties(WebSocket.prototype, prototypeAccessors);\n    return WebSocket;\n  }(EventTarget);\n  WebSocket$1.CONNECTING = 0;\n  WebSocket$1.prototype.CONNECTING = WebSocket$1.CONNECTING;\n  WebSocket$1.OPEN = 1;\n  WebSocket$1.prototype.OPEN = WebSocket$1.OPEN;\n  WebSocket$1.CLOSING = 2;\n  WebSocket$1.prototype.CLOSING = WebSocket$1.CLOSING;\n  WebSocket$1.CLOSED = 3;\n  WebSocket$1.prototype.CLOSED = WebSocket$1.CLOSED;\n\n  /*\n   * The socket-io class is designed to mimick the real API as closely as possible.\n   *\n   * http://socket.io/docs/\n   */\n  var SocketIO$1 = function (EventTarget$$1) {\n    function SocketIO(url, protocol) {\n      var this$1 = this;\n      if (url === void 0) url = 'socket.io';\n      if (protocol === void 0) protocol = '';\n      EventTarget$$1.call(this);\n      this.binaryType = 'blob';\n      var urlRecord = new urlParse(url);\n      if (!urlRecord.pathname) {\n        urlRecord.pathname = '/';\n      }\n      this.url = urlRecord.toString();\n      this.readyState = SocketIO.CONNECTING;\n      this.protocol = '';\n      this.target = this;\n      if (typeof protocol === 'string' || typeof protocol === 'object' && protocol !== null) {\n        this.protocol = protocol;\n      } else if (Array.isArray(protocol) && protocol.length > 0) {\n        this.protocol = protocol[0];\n      }\n      var server = networkBridge.attachWebSocket(this, this.url);\n\n      /*\n       * Delay triggering the connection events so they can be defined in time.\n       */\n      delay(function delayCallback() {\n        if (server) {\n          this.readyState = SocketIO.OPEN;\n          server.dispatchEvent(createEvent({\n            type: 'connection'\n          }), server, this);\n          server.dispatchEvent(createEvent({\n            type: 'connect'\n          }), server, this); // alias\n          this.dispatchEvent(createEvent({\n            type: 'connect',\n            target: this\n          }));\n        } else {\n          this.readyState = SocketIO.CLOSED;\n          this.dispatchEvent(createEvent({\n            type: 'error',\n            target: this\n          }));\n          this.dispatchEvent(createCloseEvent({\n            type: 'close',\n            target: this,\n            code: CLOSE_CODES.CLOSE_NORMAL\n          }));\n          log('error', \"Socket.io connection to '\" + this.url + \"' failed\");\n        }\n      }, this);\n\n      /**\n        Add an aliased event listener for close / disconnect\n       */\n      this.addEventListener('close', function (event) {\n        this$1.dispatchEvent(createCloseEvent({\n          type: 'disconnect',\n          target: event.target,\n          code: event.code\n        }));\n      });\n    }\n    if (EventTarget$$1) SocketIO.__proto__ = EventTarget$$1;\n    SocketIO.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    SocketIO.prototype.constructor = SocketIO;\n    var prototypeAccessors = {\n      broadcast: {}\n    };\n\n    /*\n     * Closes the SocketIO connection or connection attempt, if any.\n     * If the connection is already CLOSED, this method does nothing.\n     */\n    SocketIO.prototype.close = function close() {\n      if (this.readyState !== SocketIO.OPEN) {\n        return undefined;\n      }\n      var server = networkBridge.serverLookup(this.url);\n      networkBridge.removeWebSocket(this, this.url);\n      this.readyState = SocketIO.CLOSED;\n      this.dispatchEvent(createCloseEvent({\n        type: 'close',\n        target: this,\n        code: CLOSE_CODES.CLOSE_NORMAL\n      }));\n      if (server) {\n        server.dispatchEvent(createCloseEvent({\n          type: 'disconnect',\n          target: this,\n          code: CLOSE_CODES.CLOSE_NORMAL\n        }), server);\n      }\n      return this;\n    };\n\n    /*\n     * Alias for Socket#close\n     *\n     * https://github.com/socketio/socket.io-client/blob/master/lib/socket.js#L383\n     */\n    SocketIO.prototype.disconnect = function disconnect() {\n      return this.close();\n    };\n\n    /*\n     * Submits an event to the server with a payload\n     */\n    SocketIO.prototype.emit = function emit(event) {\n      var data = [],\n        len = arguments.length - 1;\n      while (len-- > 0) data[len] = arguments[len + 1];\n      if (this.readyState !== SocketIO.OPEN) {\n        throw new Error('SocketIO is already in CLOSING or CLOSED state');\n      }\n      var messageEvent = createMessageEvent({\n        type: event,\n        origin: this.url,\n        data: data\n      });\n      var server = networkBridge.serverLookup(this.url);\n      if (server) {\n        server.dispatchEvent.apply(server, [messageEvent].concat(data));\n      }\n      return this;\n    };\n\n    /*\n     * Submits a 'message' event to the server.\n     *\n     * Should behave exactly like WebSocket#send\n     *\n     * https://github.com/socketio/socket.io-client/blob/master/lib/socket.js#L113\n     */\n    SocketIO.prototype.send = function send(data) {\n      this.emit('message', data);\n      return this;\n    };\n\n    /*\n     * For broadcasting events to other connected sockets.\n     *\n     * e.g. socket.broadcast.emit('hi!');\n     * e.g. socket.broadcast.to('my-room').emit('hi!');\n     */\n    prototypeAccessors.broadcast.get = function () {\n      if (this.readyState !== SocketIO.OPEN) {\n        throw new Error('SocketIO is already in CLOSING or CLOSED state');\n      }\n      var self = this;\n      var server = networkBridge.serverLookup(this.url);\n      if (!server) {\n        throw new Error(\"SocketIO can not find a server at the specified URL (\" + this.url + \")\");\n      }\n      return {\n        emit: function emit(event, data) {\n          server.emit(event, data, {\n            websockets: networkBridge.websocketsLookup(self.url, null, self)\n          });\n          return self;\n        },\n        to: function to(room) {\n          return server.to(room, self);\n        },\n        in: function in$1(room) {\n          return server.in(room, self);\n        }\n      };\n    };\n\n    /*\n     * For registering events to be received from the server\n     */\n    SocketIO.prototype.on = function on(type, callback) {\n      this.addEventListener(type, callback);\n      return this;\n    };\n\n    /*\n     * Remove event listener\n     *\n     * https://github.com/component/emitter#emitteroffevent-fn\n     */\n    SocketIO.prototype.off = function off(type, callback) {\n      this.removeEventListener(type, callback);\n    };\n\n    /*\n     * Check if listeners have already been added for an event\n     *\n     * https://github.com/component/emitter#emitterhaslistenersevent\n     */\n    SocketIO.prototype.hasListeners = function hasListeners(type) {\n      var listeners = this.listeners[type];\n      if (!Array.isArray(listeners)) {\n        return false;\n      }\n      return !!listeners.length;\n    };\n\n    /*\n     * Join a room on a server\n     *\n     * http://socket.io/docs/rooms-and-namespaces/#joining-and-leaving\n     */\n    SocketIO.prototype.join = function join(room) {\n      networkBridge.addMembershipToRoom(this, room);\n    };\n\n    /*\n     * Get the websocket to leave the room\n     *\n     * http://socket.io/docs/rooms-and-namespaces/#joining-and-leaving\n     */\n    SocketIO.prototype.leave = function leave(room) {\n      networkBridge.removeMembershipFromRoom(this, room);\n    };\n    SocketIO.prototype.to = function to(room) {\n      return this.broadcast.to(room);\n    };\n    SocketIO.prototype.in = function in$1() {\n      return this.to.apply(null, arguments);\n    };\n\n    /*\n     * Invokes all listener functions that are listening to the given event.type property. Each\n     * listener will be passed the event as the first argument.\n     *\n     * @param {object} event - event object which will be passed to all listeners of the event.type property\n     */\n    SocketIO.prototype.dispatchEvent = function dispatchEvent(event) {\n      var this$1 = this;\n      var customArguments = [],\n        len = arguments.length - 1;\n      while (len-- > 0) customArguments[len] = arguments[len + 1];\n      var eventName = event.type;\n      var listeners = this.listeners[eventName];\n      if (!Array.isArray(listeners)) {\n        return false;\n      }\n      listeners.forEach(function (listener) {\n        if (customArguments.length > 0) {\n          listener.apply(this$1, customArguments);\n        } else {\n          // Regular WebSockets expect a MessageEvent but Socketio.io just wants raw data\n          //  payload instanceof MessageEvent works, but you can't isntance of NodeEvent\n          //  for now we detect if the output has data defined on it\n          listener.call(this$1, event.data ? event.data : event);\n        }\n      });\n    };\n    Object.defineProperties(SocketIO.prototype, prototypeAccessors);\n    return SocketIO;\n  }(EventTarget);\n  SocketIO$1.CONNECTING = 0;\n  SocketIO$1.OPEN = 1;\n  SocketIO$1.CLOSING = 2;\n  SocketIO$1.CLOSED = 3;\n\n  /*\n   * Static constructor methods for the IO Socket\n   */\n  var IO = function ioConstructor(url, protocol) {\n    return new SocketIO$1(url, protocol);\n  };\n\n  /*\n   * Alias the raw IO() constructor\n   */\n  IO.connect = function ioConnect(url, protocol) {\n    /* eslint-disable new-cap */\n    return IO(url, protocol);\n    /* eslint-enable new-cap */\n  };\n\n  var dedupe = function (arr) {\n    return arr.reduce(function (deduped, b) {\n      if (deduped.indexOf(b) > -1) {\n        return deduped;\n      }\n      return deduped.concat(b);\n    }, []);\n  };\n  function retrieveGlobalObject() {\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n    return typeof process === 'object' && typeof require === 'function' && typeof global === 'object' ? global : this;\n  }\n  var defaultOptions = {\n    mock: true,\n    verifyClient: null,\n    selectProtocol: null\n  };\n  var Server$1 = function (EventTarget$$1) {\n    function Server(url, options) {\n      if (options === void 0) options = defaultOptions;\n      EventTarget$$1.call(this);\n      var urlRecord = new urlParse(url);\n      if (!urlRecord.pathname) {\n        urlRecord.pathname = '/';\n      }\n      this.url = urlRecord.toString();\n      this.originalWebSocket = null;\n      var server = networkBridge.attachServer(this, this.url);\n      if (!server) {\n        this.dispatchEvent(createEvent({\n          type: 'error'\n        }));\n        throw new Error('A mock server is already listening on this url');\n      }\n      this.options = Object.assign({}, defaultOptions, options);\n      if (this.options.mock) {\n        this.mockWebsocket();\n      }\n    }\n    if (EventTarget$$1) Server.__proto__ = EventTarget$$1;\n    Server.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    Server.prototype.constructor = Server;\n\n    /*\n     * Attaches the mock websocket object to the global object\n     */\n    Server.prototype.mockWebsocket = function mockWebsocket() {\n      var globalObj = retrieveGlobalObject();\n      this.originalWebSocket = globalObj.WebSocket;\n      globalObj.WebSocket = WebSocket$1;\n    };\n\n    /*\n     * Removes the mock websocket object from the global object\n     */\n    Server.prototype.restoreWebsocket = function restoreWebsocket() {\n      var globalObj = retrieveGlobalObject();\n      if (this.originalWebSocket !== null) {\n        globalObj.WebSocket = this.originalWebSocket;\n      }\n      this.originalWebSocket = null;\n    };\n\n    /**\n     * Removes itself from the urlMap so another server could add itself to the url.\n     * @param {function} callback - The callback is called when the server is stopped\n     */\n    Server.prototype.stop = function stop(callback) {\n      if (callback === void 0) callback = function () {};\n      if (this.options.mock) {\n        this.restoreWebsocket();\n      }\n      networkBridge.removeServer(this.url);\n      if (typeof callback === 'function') {\n        callback();\n      }\n    };\n\n    /*\n     * This is the main function for the mock server to subscribe to the on events.\n     *\n     * ie: mockServer.on('connection', function() { console.log('a mock client connected'); });\n     *\n     * @param {string} type - The event key to subscribe to. Valid keys are: connection, message, and close.\n     * @param {function} callback - The callback which should be called when a certain event is fired.\n     */\n    Server.prototype.on = function on(type, callback) {\n      this.addEventListener(type, callback);\n    };\n\n    /*\n     * Remove event listener\n     */\n    Server.prototype.off = function off(type, callback) {\n      this.removeEventListener(type, callback);\n    };\n\n    /*\n     * Closes the connection and triggers the onclose method of all listening\n     * websockets. After that it removes itself from the urlMap so another server\n     * could add itself to the url.\n     *\n     * @param {object} options\n     */\n    Server.prototype.close = function close(options) {\n      if (options === void 0) options = {};\n      var code = options.code;\n      var reason = options.reason;\n      var wasClean = options.wasClean;\n      var listeners = networkBridge.websocketsLookup(this.url);\n\n      // Remove server before notifications to prevent immediate reconnects from\n      // socket onclose handlers\n      networkBridge.removeServer(this.url);\n      listeners.forEach(function (socket) {\n        socket.readyState = WebSocket$1.CLOSED;\n        socket.dispatchEvent(createCloseEvent({\n          type: 'close',\n          target: socket.target,\n          code: code || CLOSE_CODES.CLOSE_NORMAL,\n          reason: reason || '',\n          wasClean: wasClean\n        }));\n      });\n      this.dispatchEvent(createCloseEvent({\n        type: 'close'\n      }), this);\n    };\n\n    /*\n     * Sends a generic message event to all mock clients.\n     */\n    Server.prototype.emit = function emit(event, data, options) {\n      var this$1 = this;\n      if (options === void 0) options = {};\n      var websockets = options.websockets;\n      if (!websockets) {\n        websockets = networkBridge.websocketsLookup(this.url);\n      }\n      var normalizedData;\n      if (typeof options !== 'object' || arguments.length > 3) {\n        data = Array.prototype.slice.call(arguments, 1, arguments.length);\n        normalizedData = data.map(function (item) {\n          return normalizeSendData(item);\n        });\n      } else {\n        normalizedData = normalizeSendData(data);\n      }\n      websockets.forEach(function (socket) {\n        var messageData = socket instanceof SocketIO$1 ? data : normalizedData;\n        if (Array.isArray(messageData)) {\n          socket.dispatchEvent.apply(socket, [createMessageEvent({\n            type: event,\n            data: messageData,\n            origin: this$1.url,\n            target: socket.target\n          })].concat(messageData));\n        } else {\n          socket.dispatchEvent(createMessageEvent({\n            type: event,\n            data: messageData,\n            origin: this$1.url,\n            target: socket.target\n          }));\n        }\n      });\n    };\n\n    /*\n     * Returns an array of websockets which are listening to this server\n     * TOOD: this should return a set and not be a method\n     */\n    Server.prototype.clients = function clients() {\n      return networkBridge.websocketsLookup(this.url);\n    };\n\n    /*\n     * Prepares a method to submit an event to members of the room\n     *\n     * e.g. server.to('my-room').emit('hi!');\n     */\n    Server.prototype.to = function to(room, broadcaster, broadcastList) {\n      var this$1 = this;\n      if (broadcastList === void 0) broadcastList = [];\n      var self = this;\n      var websockets = dedupe(broadcastList.concat(networkBridge.websocketsLookup(this.url, room, broadcaster)));\n      return {\n        to: function (chainedRoom, chainedBroadcaster) {\n          return this$1.to.call(this$1, chainedRoom, chainedBroadcaster, websockets);\n        },\n        emit: function emit(event, data) {\n          self.emit(event, data, {\n            websockets: websockets\n          });\n        }\n      };\n    };\n\n    /*\n     * Alias for Server.to\n     */\n    Server.prototype.in = function in$1() {\n      var args = [],\n        len = arguments.length;\n      while (len--) args[len] = arguments[len];\n      return this.to.apply(null, args);\n    };\n\n    /*\n     * Simulate an event from the server to the clients. Useful for\n     * simulating errors.\n     */\n    Server.prototype.simulate = function simulate(event) {\n      var listeners = networkBridge.websocketsLookup(this.url);\n      if (event === 'error') {\n        listeners.forEach(function (socket) {\n          socket.readyState = WebSocket$1.CLOSED;\n          socket.dispatchEvent(createEvent({\n            type: 'error',\n            target: socket.target\n          }));\n        });\n      }\n    };\n    return Server;\n  }(EventTarget);\n\n  /*\n   * Alternative constructor to support namespaces in socket.io\n   *\n   * http://socket.io/docs/rooms-and-namespaces/#custom-namespaces\n   */\n  Server$1.of = function of(url) {\n    return new Server$1(url);\n  };\n  var Server = Server$1;\n  var WebSocket = WebSocket$1;\n  var SocketIO$$1 = IO;\n  exports.Server = Server;\n  exports.WebSocket = WebSocket;\n  exports.SocketIO = SocketIO$$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}