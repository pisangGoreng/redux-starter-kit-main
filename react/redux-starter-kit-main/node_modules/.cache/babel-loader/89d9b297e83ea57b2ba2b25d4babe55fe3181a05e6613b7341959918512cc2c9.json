{"ast":null,"code":"import { printBlockString } from './blockString.mjs';\nimport { printString } from './printString.mjs';\nimport { visit } from './visitor.mjs';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, printDocASTReducer);\n}\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' '); // Anonymous queries with no directives or variable definitions can use\n      // the query short form.\n\n      return (prefix === 'query' ? '' : prefix + ' ') + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: _ref => {\n      let {\n        variable,\n        type,\n        defaultValue,\n        directives\n      } = _ref;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: _ref2 => {\n      let {\n        selections\n      } = _ref2;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave(_ref3) {\n      let {\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      } = _ref3;\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  Argument: {\n    leave: _ref4 => {\n      let {\n        name,\n        value\n      } = _ref4;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: _ref5 => {\n      let {\n        name,\n        directives\n      } = _ref5;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: _ref6 => {\n      let {\n        typeCondition,\n        directives,\n        selectionSet\n      } = _ref6;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: (_ref7 // Note: fragment variable definitions are experimental and may be changed\n    ) => {\n      let {\n        name,\n        typeCondition,\n        variableDefinitions,\n        directives,\n        selectionSet\n      } = _ref7;\n      return (\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: _ref8 => {\n      let {\n        value\n      } = _ref8;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: _ref9 => {\n      let {\n        value\n      } = _ref9;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: _ref10 => {\n      let {\n        value,\n        block: isBlockString\n      } = _ref10;\n      return isBlockString ? printBlockString(value) : printString(value);\n    }\n  },\n  BooleanValue: {\n    leave: _ref11 => {\n      let {\n        value\n      } = _ref11;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: _ref12 => {\n      let {\n        value\n      } = _ref12;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: _ref13 => {\n      let {\n        values\n      } = _ref13;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: _ref14 => {\n      let {\n        fields\n      } = _ref14;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: _ref15 => {\n      let {\n        name,\n        value\n      } = _ref15;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: _ref16 => {\n      let {\n        name,\n        arguments: args\n      } = _ref16;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: _ref17 => {\n      let {\n        name\n      } = _ref17;\n      return name;\n    }\n  },\n  ListType: {\n    leave: _ref18 => {\n      let {\n        type\n      } = _ref18;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: _ref19 => {\n      let {\n        type\n      } = _ref19;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: _ref20 => {\n      let {\n        description,\n        directives,\n        operationTypes\n      } = _ref20;\n      return wrap('', description, '\\n') + join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: _ref21 => {\n      let {\n        operation,\n        type\n      } = _ref21;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: _ref22 => {\n      let {\n        description,\n        name,\n        directives\n      } = _ref22;\n      return wrap('', description, '\\n') + join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: _ref23 => {\n      let {\n        description,\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref23;\n      return wrap('', description, '\\n') + join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: _ref24 => {\n      let {\n        description,\n        name,\n        arguments: args,\n        type,\n        directives\n      } = _ref24;\n      return wrap('', description, '\\n') + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: _ref25 => {\n      let {\n        description,\n        name,\n        type,\n        defaultValue,\n        directives\n      } = _ref25;\n      return wrap('', description, '\\n') + join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: _ref26 => {\n      let {\n        description,\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref26;\n      return wrap('', description, '\\n') + join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: _ref27 => {\n      let {\n        description,\n        name,\n        directives,\n        types\n      } = _ref27;\n      return wrap('', description, '\\n') + join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: _ref28 => {\n      let {\n        description,\n        name,\n        directives,\n        values\n      } = _ref28;\n      return wrap('', description, '\\n') + join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: _ref29 => {\n      let {\n        description,\n        name,\n        directives\n      } = _ref29;\n      return wrap('', description, '\\n') + join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: _ref30 => {\n      let {\n        description,\n        name,\n        directives,\n        fields\n      } = _ref30;\n      return wrap('', description, '\\n') + join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: _ref31 => {\n      let {\n        description,\n        name,\n        arguments: args,\n        repeatable,\n        locations\n      } = _ref31;\n      return wrap('', description, '\\n') + 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: _ref32 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref32;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: _ref33 => {\n      let {\n        name,\n        directives\n      } = _ref33;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: _ref34 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref34;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: _ref35 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref35;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: _ref36 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref36;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: _ref37 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref37;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: _ref38 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref38;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\nfunction join(maybeArray) {\n  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var _maybeArray$filter$jo;\n  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(x => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an indented `{ }` block.\n */\n\nfunction block(array) {\n  return wrap('{\\n', indent(join(array, '\\n')), '\\n}');\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */\n\nfunction wrap(start, maybeString) {\n  let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return maybeString != null && maybeString !== '' ? start + maybeString + end : '';\n}\nfunction indent(str) {\n  return wrap('  ', str.replace(/\\n/g, '\\n  '));\n}\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some;\n\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}