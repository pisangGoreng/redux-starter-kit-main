{"ast":null,"code":"import { c as commonjsGlobal, l as lib$1, j as jsonParse, s as status, b as set, e as delay, f as fetch } from './fetch-deps.js';\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nvar lib = {};\nvar invariant$1 = {};\nvar format$1 = {};\nObject.defineProperty(format$1, \"__esModule\", {\n  value: true\n});\nformat$1.format = void 0;\nvar POSITIONALS_EXP = /(%?)(%([sdjo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional;\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional);\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional);\n    // Objects.\n    case 'o':\n      {\n        // Preserve stings to prevent extra quotes around them.\n        if (typeof positional === 'string') {\n          return positional;\n        }\n        var json = JSON.stringify(positional);\n        // If the positional isn't serializable, return it as-is.\n        if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message) {\n  var positionals = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positionals[_i - 1] = arguments[_i];\n  }\n  if (positionals.length === 0) {\n    return message;\n  }\n  var positionalIndex = 0;\n  var formattedMessage = message.replace(POSITIONALS_EXP, function (match, isEscaped, _, flag) {\n    var positional = positionals[positionalIndex];\n    var value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += \" \" + positionals.slice(positionalIndex).join(' ');\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%');\n  return formattedMessage;\n}\nformat$1.format = format;\nvar __extends = commonjsGlobal && commonjsGlobal.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nObject.defineProperty(invariant$1, \"__esModule\", {\n  value: true\n});\ninvariant$1.invariant = invariant$1.InvariantError = void 0;\nvar format_1 = format$1;\nvar STACK_FRAMES_TO_IGNORE = 2;\nvar InvariantError = /** @class */function (_super) {\n  __extends(InvariantError, _super);\n  function InvariantError(message) {\n    var positionals = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      positionals[_i - 1] = arguments[_i];\n    }\n    var _this = _super.call(this, message) || this;\n    _this.name = 'Invariant Violation';\n    _this.message = format_1.format.apply(void 0, __spreadArray([message], positionals));\n    if (_this.stack) {\n      var nextStack = _this.stack.split('\\n');\n      nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n      _this.stack = nextStack.join('\\n');\n    }\n    return _this;\n  }\n  return InvariantError;\n}(Error);\ninvariant$1.InvariantError = InvariantError;\nfunction invariant(predicate, message) {\n  var positionals = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    positionals[_i - 2] = arguments[_i];\n  }\n  if (!predicate) {\n    throw new (InvariantError.bind.apply(InvariantError, __spreadArray([void 0, message], positionals)))();\n  }\n}\ninvariant$1.invariant = invariant;\n(function (exports) {\n  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    });\n  } : function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  };\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  __exportStar(invariant$1, exports);\n  __exportStar(format$1, exports);\n})(lib);\nconst LIBRARY_PREFIX = '[MSW]';\n/**\r\n * Formats a given message by appending the library's prefix string.\r\n */\nfunction formatMessage(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n  const interpolatedMessage = lib.format(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\n/**\r\n * Prints a library-specific warning.\r\n */\nfunction warn(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n  console.warn(formatMessage(message, ...positionals));\n}\n/**\r\n * Prints a library-specific error.\r\n */\nfunction error(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n  console.error(formatMessage(message, ...positionals));\n}\nconst devUtils = {\n  formatMessage,\n  warn,\n  error\n};\nclass NetworkError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n}\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = lib$1.stringToHeaders(headersString);\n  const contentType = headers.get('content-type') || 'text/plain';\n  const disposition = headers.get('content-disposition');\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=');\n    acc[name] = rest.join('=');\n    return acc;\n  }, {});\n  const name = (_a = directives.name) === null || _a === void 0 ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) === null || _b === void 0 ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\n/**\r\n * Parses a given string as a multipart/form-data.\r\n * Does not throw an exception on an invalid multipart string.\r\n */\nfunction parseMultipartData(data, headers) {\n  const contentType = headers === null || headers === void 0 ? void 0 : headers.get('content-type');\n  if (!contentType) {\n    return undefined;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith('boundary=')).map(s => s.replace(/^boundary=/, ''))[0];\n  if (!boundary) {\n    return undefined;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data.split(boundaryRegExp).filter(chunk => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n')).map(chunk => chunk.trimStart().replace(/\\r\\n$/, ''));\n  if (!fields.length) {\n    return undefined;\n  }\n  const parsedBody = {};\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n');\n      const contentBody = rest.join('\\r\\n\\r\\n');\n      const {\n        contentType,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === undefined ? contentBody : new File([contentBody], filename, {\n        type: contentType\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === undefined) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error) {\n    return undefined;\n  }\n}\n\n/**\r\n * Parses a given request/response body based on the \"Content-Type\" header.\r\n */\nfunction parseBody(body, headers) {\n  var _a;\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body;\n  }\n  const contentType = ((_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data');\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body;\n  }\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json');\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body;\n  }\n  // Otherwise leave as-is.\n  return body;\n}\n\n/**\r\n * Returns a relative URL if the given request URL is relative to the current origin.\r\n * Otherwise returns an absolute URL.\r\n */\nconst getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n};\nvar StatusCodeColor;\n(function (StatusCodeColor) {\n  StatusCodeColor[\"Success\"] = \"#69AB32\";\n  StatusCodeColor[\"Warning\"] = \"#F0BB4B\";\n  StatusCodeColor[\"Danger\"] = \"#E95F5D\";\n})(StatusCodeColor || (StatusCodeColor = {}));\n/**\r\n * Returns a HEX color for a given response status code number.\r\n */\nfunction getStatusCodeColor(status) {\n  if (status < 300) {\n    return StatusCodeColor.Success;\n  }\n  if (status < 400) {\n    return StatusCodeColor.Warning;\n  }\n  return StatusCodeColor.Danger;\n}\n\n/**\r\n * Returns a timestamp string in a \"HH:MM:SS\" format.\r\n */\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, '0')).join(':');\n}\n\n/**\r\n * Formats a mocked request for introspection in browser's console.\r\n */\nfunction prepareRequest(request) {\n  return Object.assign(Object.assign({}, request), {\n    headers: request.headers.all()\n  });\n}\n\n/**\r\n * Formats a mocked response for introspection in the browser's console.\r\n */\nfunction prepareResponse(res) {\n  const responseHeaders = lib$1.objectToHeaders(res.headers);\n  return Object.assign(Object.assign({}, res), {\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders)\n  });\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n  while (i < str.length) {\n    var char = str[i];\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({\n        type: \"MODIFIER\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \"\\\\\") {\n      tokens.push({\n        type: \"ESCAPED_CHAR\",\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \"{\") {\n      tokens.push({\n        type: \"OPEN\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \"}\") {\n      tokens.push({\n        type: \"CLOSE\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \":\") {\n      var name = \"\";\n      var j = i + 1;\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n        if (\n        // `0-9`\n        code >= 48 && code <= 57 ||\n        // `A-Z`\n        code >= 65 && code <= 90 ||\n        // `a-z`\n        code >= 97 && code <= 122 ||\n        // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n        break;\n      }\n      if (!name) throw new TypeError(\"Missing parameter name at \" + i);\n      tokens.push({\n        type: \"NAME\",\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n    if (char === \"(\") {\n      var count = 1;\n      var pattern = \"\";\n      var j = i + 1;\n      if (str[j] === \"?\") {\n        throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n      }\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(\"Capturing groups are not allowed at \" + j);\n          }\n        }\n        pattern += str[j++];\n      }\n      if (count) throw new TypeError(\"Unbalanced pattern at \" + i);\n      if (!pattern) throw new TypeError(\"Missing pattern at \" + i);\n      tokens.push({\n        type: \"PATTERN\",\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n    tokens.push({\n      type: \"CHAR\",\n      index: i,\n      value: str[i++]\n    });\n  }\n  tokens.push({\n    type: \"END\",\n    index: i,\n    value: \"\"\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n    prefixes = _a === void 0 ? \"./\" : _a;\n  var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = \"\";\n  var tryConsume = function (type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n  var mustConsume = function (type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n      nextType = _a.type,\n      index = _a.index;\n    throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n  };\n  var consumeText = function () {\n    var result = \"\";\n    var value;\n    // tslint:disable-next-line\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result += value;\n    }\n    return result;\n  };\n  while (i < tokens.length) {\n    var char = tryConsume(\"CHAR\");\n    var name = tryConsume(\"NAME\");\n    var pattern = tryConsume(\"PATTERN\");\n    if (name || pattern) {\n      var prefix = char || \"\";\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n    var value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n    var open = tryConsume(\"OPEN\");\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume(\"NAME\") || \"\";\n      var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n      var suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : \"\"),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n    mustConsume(\"END\");\n  }\n  return result;\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.decode,\n    decode = _a === void 0 ? function (x) {\n      return x;\n    } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n      index = m.index;\n    var params = Object.create(null);\n    var _loop_1 = function (i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return \"continue\";\n      var key = keys[i - 1];\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path;\n  var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n  var index = 0;\n  var execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.strict,\n    strict = _a === void 0 ? false : _a,\n    _b = options.start,\n    start = _b === void 0 ? true : _b,\n    _c = options.end,\n    end = _c === void 0 ? true : _c,\n    _d = options.encode,\n    encode = _d === void 0 ? function (x) {\n      return x;\n    } : _d;\n  var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n  var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n  var route = start ? \"^\" : \"\";\n  // Iterate over the tokens and create our regexp string.\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n      if (token.pattern) {\n        if (keys) keys.push(token);\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            var mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n          } else {\n            route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n          }\n        } else {\n          route += \"(\" + token.pattern + \")\" + token.modifier;\n        }\n      } else {\n        route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n      }\n    }\n  }\n  if (end) {\n    if (!strict) route += delimiter + \"?\";\n    route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 :\n    // tslint:disable-next-line\n    endToken === undefined;\n    if (!strict) {\n      route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n    }\n    if (!isEndDelimited) {\n      route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n    }\n  }\n  return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\nconst REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, 'http://localhost').searchParams;\n}\n/**\r\n * Removes query parameters and hashes from a given URL string.\r\n */\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '');\n}\n\n/**\r\n * Determines if the given URL string is an absolute URL.\r\n */\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n/**\r\n * Returns an absolute URL based on the given path.\r\n */\nfunction getAbsoluteUrl(path, baseUrl) {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path;\n  }\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin = baseUrl || typeof document !== 'undefined' && document.baseURI;\n  return origin ?\n  // Encode and decode the path to preserve escaped characters.\n  decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n/**\r\n * Normalizes a given request handler path:\r\n * - Preserves RegExp.\r\n * - Removes query parameters and hashes.\r\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\r\n * - Preserves relative URLs in Node.js, unless specified otherwise.\r\n */\nfunction normalizePath(path, baseUrl) {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n/**\r\n * Coerce a path supported by MSW into a path\r\n * supported by \"path-to-regexp\".\r\n */\nfunction coercePath(path) {\n  return path\n  /**\r\n   * Replace wildcards (\"*\") with unnamed capturing groups\r\n   * because \"path-to-regexp\" doesn't support wildcards.\r\n   * Ignore path parameter' modifiers (i.e. \":name*\").\r\n   */.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = '(.*)';\n    if (!parameterName) {\n      return expression;\n    }\n    return parameterName.startsWith(':') ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  })\n  /**\r\n   * Escape the port so that \"path-to-regexp\" can match\r\n   * absolute URLs including port numbers.\r\n   */.replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n  /**\r\n   * Escape the protocol so that \"path-to-regexp\" could match\r\n   * absolute URL.\r\n   * @see https://github.com/pillarjs/path-to-regexp/issues/259\r\n   */.replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2');\n}\n/**\r\n * Returns the result of matching given request URL against a mask.\r\n */\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === 'string' ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl = getCleanUrl(url);\n  const result = match(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n/**\r\n * Composes a given list of functions into a new function that\r\n * executes from right to left.\r\n */\nfunction compose() {\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n}\nconst defaultResponse = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false\n};\nconst defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides) {\n  var _this2 = this;\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return function () {\n    for (var _len5 = arguments.length, transformers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      transformers[_key5] = arguments[_key5];\n    }\n    return __awaiter(_this2, void 0, void 0, function* () {\n      const initialResponse = Object.assign({}, defaultResponse, {\n        headers: new lib$1.Headers({\n          'x-powered-by': 'msw'\n        })\n      }, responseOverrides);\n      const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n      const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n      return resolvedResponse;\n    });\n  };\n}\nconst response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\nconst BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\n/**\r\n * Return the stack trace frame of a function's invocation.\r\n */\nfunction getCallFrame(error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split('\\n').slice(1);\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find(frame => {\n    return !BUILD_FRAME.test(frame);\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1').replace(/^@/, '');\n  return declarationPath;\n}\n\n/**\r\n * Determines if the given function is an iterator.\r\n */\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == 'function';\n}\nconst defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nclass RequestHandler {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = Object.assign(Object.assign({}, options.info), {\n      callFrame\n    });\n  }\n  /**\r\n   * Parse the captured request to extract additional information from it.\r\n   * Parsed result is then exposed to other methods of this request handler.\r\n   */\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  /**\r\n   * Test if this handler matches the given request.\r\n   */\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n  /**\r\n   * Derive the publicly exposed request (`req`) instance of the response resolver\r\n   * from the captured request and its parsed result.\r\n   */\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n  /**\r\n   * Execute this request handler and produce a mocked response\r\n   * using the given resolver function.\r\n   */\n  run(request, resolutionContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.shouldSkip) {\n        return null;\n      }\n      const parsedResult = this.parse(request, resolutionContext);\n      const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n      if (!shouldIntercept) {\n        return null;\n      }\n      const publicRequest = this.getPublicRequest(request, parsedResult);\n      // Create a response extraction wrapper around the resolver\n      // since it can be both an async function and a generator.\n      const executeResolver = this.wrapResolver(this.resolver);\n      const mockedResponse = yield executeResolver(publicRequest, response, this.ctx);\n      return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n    });\n  }\n  wrapResolver(resolver) {\n    return (req, res, ctx) => __awaiter(this, void 0, void 0, function* () {\n      const result = this.resolverGenerator || (yield resolver(req, res, ctx));\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = yield value;\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    });\n  }\n  createExecutionResult(parsedResult, request, response) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null\n    };\n  }\n}\nexport { NetworkError as N, RequestHandler as R, __awaiter as _, defaultResponse as a, defaultContext as b, createResponseComposition as c, devUtils as d, compose as e, cleanUrl as f, getPublicUrlFromRequest as g, getSearchParams as h, prepareRequest as i, prepareResponse as j, getStatusCodeColor as k, getTimestamp as l, matchRequestUrl as m, __rest as n, parseBody as p, response as r };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}