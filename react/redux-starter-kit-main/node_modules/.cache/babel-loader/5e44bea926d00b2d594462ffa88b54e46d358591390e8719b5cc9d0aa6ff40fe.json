{"ast":null,"code":"export { i as context } from './index-deps.js';\nimport { c as commonjsGlobal, p as parse_1, l as lib$2, a as lib$3, j as jsonParse } from './fetch-deps.js';\nimport { _ as __awaiter, d as devUtils, p as parseBody, g as getPublicUrlFromRequest, N as NetworkError } from './RequestHandler-deps.js';\nexport { R as RequestHandler, f as cleanUrl, e as compose, c as createResponseComposition, b as defaultContext, a as defaultResponse, m as matchRequestUrl, r as response } from './RequestHandler-deps.js';\nimport { store } from '@mswjs/cookies';\nimport { i as isStringEqual, R as RestHandler } from './rest-deps.js';\nexport { a as RESTMethods, R as RestHandler, r as rest, b as restContext } from './rest-deps.js';\nimport { t as tryCatch, p as parseGraphQLRequest, G as GraphQLHandler } from './graphql-deps.js';\nexport { G as GraphQLHandler, g as graphql, a as graphqlContext } from './graphql-deps.js';\nimport { m as mergeRight } from './errors-deps.js';\nimport { createInterceptor } from '@mswjs/interceptors';\nimport { interceptFetch } from '@mswjs/interceptors/lib/interceptors/fetch';\nimport { interceptXMLHttpRequest } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest';\nimport './xml-deps.js';\nimport '@mswjs/interceptors/lib/utils/getCleanUrl';\nvar lib$1 = {};\nvar StrictEventEmitter$1 = {};\nvar events = {\n  exports: {}\n};\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\nvar __extends = commonjsGlobal && commonjsGlobal.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\nStrictEventEmitter$1.__esModule = true;\nStrictEventEmitter$1.StrictEventEmitter = void 0;\nvar events_1 = events.exports;\nvar StrictEventEmitter = /** @class */function (_super) {\n  __extends(StrictEventEmitter, _super);\n  function StrictEventEmitter() {\n    return _super.call(this) || this;\n  }\n  StrictEventEmitter.prototype.on = function (event, listener) {\n    return _super.prototype.on.call(this, event.toString(), listener);\n  };\n  StrictEventEmitter.prototype.once = function (event, listener) {\n    return _super.prototype.on.call(this, event.toString(), listener);\n  };\n  StrictEventEmitter.prototype.off = function (event, listener) {\n    return _super.prototype.off.call(this, event.toString(), listener);\n  };\n  StrictEventEmitter.prototype.emit = function (event) {\n    var data = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      data[_i - 1] = arguments[_i];\n    }\n    return _super.prototype.emit.apply(this, __spreadArrays([event.toString()], data));\n  };\n  StrictEventEmitter.prototype.addListener = function (event, listener) {\n    return _super.prototype.addListener.call(this, event.toString(), listener);\n  };\n  StrictEventEmitter.prototype.removeListener = function (event, listener) {\n    return _super.prototype.removeListener.call(this, event.toString(), listener);\n  };\n  return StrictEventEmitter;\n}(events_1.EventEmitter);\nStrictEventEmitter$1.StrictEventEmitter = StrictEventEmitter;\n(function (exports) {\n  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    });\n  } : function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n  exports.__esModule = true;\n  exports.StrictEventEmitter = void 0;\n  var StrictEventEmitter_1 = StrictEventEmitter$1;\n  __createBinding(exports, StrictEventEmitter_1, \"StrictEventEmitter\");\n})(lib$1);\nvar lib = {};\nvar until$1 = {};\nObject.defineProperty(until$1, \"__esModule\", {\n  value: true\n});\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * cosnt [error, data] = await until(() => asyncAction())\n */\nuntil$1.until = async promise => {\n  try {\n    const data = await promise().catch(error => {\n      throw error;\n    });\n    return [null, data];\n  } catch (error) {\n    return [error, null];\n  }\n};\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\nvar until_1 = until$1;\nvar until = lib.until = until_1.until;\n\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\nconst getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n}\n\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\nconst getWorkerInstance = function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    // Resolve the absolute Service Worker URL.\n    const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n    const mockRegistrations = yield navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n    if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n      // Reload the page when it has associated workers, but no active controller.\n      // The absence of a controller can mean either:\n      // - page has no Service Worker associated with it\n      // - page has been hard-reloaded and its workers won't be used until the next reload.\n      // Since we've checked that there are registrations associated with this page,\n      // at this point we are sure it's hard reload that falls into this clause.\n      location.reload();\n    }\n    const [existingRegistration] = mockRegistrations;\n    if (existingRegistration) {\n      // When the Service Worker is registered, update it and return the reference.\n      return existingRegistration.update().then(() => {\n        return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n      });\n    }\n    // When the Service Worker wasn't found, register it anew and return the reference.\n    const [error, instance] = yield until(() => __awaiter(void 0, void 0, void 0, function* () {\n      const registration = yield navigator.serviceWorker.register(url, options);\n      return [\n      // Compare existing worker registration by its worker URL,\n      // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n      getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n    }));\n    // Handle Service Worker registration errors.\n    if (error) {\n      const isWorkerMissing = error.message.includes('(404)');\n      // Produce a custom error message when given a non-existing Service Worker url.\n      // Suggest developers to check their setup.\n      if (isWorkerMissing) {\n        const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\n        throw new Error(devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n      }\n      // Fallback error message for any other registration errors.\n      throw new Error(devUtils.formatMessage('Failed to register the Service Worker:\\n\\n%s', error.message));\n    }\n    return instance;\n  });\n};\n\n/**\r\n * Prints a worker activation message in the browser's console.\r\n */\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || 'Mocking enabled.';\n  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, 'color:orangered;font-weight:bold;');\n  console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\n  console.log('Found an issue? https://github.com/mswjs/msw/issues');\n  console.groupEnd();\n}\n\n/**\r\n * Signals the worker to enable the interception of requests.\r\n */\nfunction enableMocking(context, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    context.workerChannel.send('MOCK_ACTIVATE');\n    return context.events.once('MOCKING_ENABLED').then(() => {\n      printStartMessage({\n        quiet: options.quiet\n      });\n    });\n  });\n}\n\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\nconst createBroadcastChannel = event => {\n  const port = event.ports[0];\n  return {\n    /**\r\n     * Sends a text message to the connected Service Worker.\r\n     */\n    send(message) {\n      if (port) {\n        port.postMessage(message);\n      }\n    }\n  };\n};\nfunction getAllCookies() {\n  return parse_1(document.cookie);\n}\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\nfunction getRequestCookies(request) {\n  /**\r\n   * @note No cookies persist on the document in Node.js: no document.\r\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {};\n  }\n  switch (request.credentials) {\n    case 'same-origin':\n      {\n        // Return document cookies only when requested a resource\n        // from the same origin as the current document.\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n    case 'include':\n      {\n        // Return all document cookies.\n        return getAllCookies();\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\nfunction setRequestCookies(request) {\n  var _a;\n  store.hydrate();\n  request.cookies = Object.assign(Object.assign({}, getRequestCookies(request)), Array.from((_a = store.get(Object.assign(Object.assign({}, request), {\n    url: request.url.toString()\n  }))) === null || _a === void 0 ? void 0 : _a.entries()).reduce((cookies, _ref) => {\n    let [name, {\n      value\n    }] = _ref;\n    return Object.assign(cookies, {\n      [name]: value\n    });\n  }, {}));\n  request.headers.set('cookie', Object.entries(request.cookies).map(_ref2 => {\n    let [name, value] = _ref2;\n    return `${name}=${value}`;\n  }).join('; '));\n}\n\n/**\r\n * Ensures that an empty GET request body is always represented as `undefined`.\r\n */\nfunction pruneGetRequestBody(request) {\n  if (request.method && isStringEqual(request.method, 'GET') && request.body === '') {\n    return undefined;\n  }\n  return request.body;\n}\n\n/**\r\n * Converts a given request received from the Service Worker\r\n * into a `MockedRequest` instance.\r\n */\nfunction parseWorkerRequest(rawRequest) {\n  const request = {\n    id: rawRequest.id,\n    cache: rawRequest.cache,\n    credentials: rawRequest.credentials,\n    method: rawRequest.method,\n    url: new URL(rawRequest.url),\n    referrer: rawRequest.referrer,\n    referrerPolicy: rawRequest.referrerPolicy,\n    redirect: rawRequest.redirect,\n    mode: rawRequest.mode,\n    params: {},\n    cookies: {},\n    integrity: rawRequest.integrity,\n    keepalive: rawRequest.keepalive,\n    destination: rawRequest.destination,\n    body: pruneGetRequestBody(rawRequest),\n    bodyUsed: rawRequest.bodyUsed,\n    headers: new lib$2.Headers(rawRequest.headers)\n  };\n  // Set document cookies on the request.\n  setRequestCookies(request);\n  // Parse the request's body based on the \"Content-Type\" header.\n  request.body = parseBody(request.body, request.headers);\n  return request;\n}\n\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\nconst getResponse = (request, handlers, resolutionContext) => __awaiter(void 0, void 0, void 0, function* () {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined\n    };\n  }\n  const result = yield relevantHandlers.reduce((executionResult, handler) => __awaiter(void 0, void 0, void 0, function* () {\n    const previousResults = yield executionResult;\n    if (!!(previousResults === null || previousResults === void 0 ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result = yield handler.run(request, resolutionContext);\n    if (result === null || result.handler.shouldSkip) {\n      return null;\n    }\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult\n      };\n    }\n    if (result.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result;\n  }), Promise.resolve(null));\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n});\nvar jsLevenshtein = function () {\n  function _min(d0, d1, d2, bx, ay) {\n    return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n  }\n  return function (a, b) {\n    if (a === b) {\n      return 0;\n    }\n    if (a.length > b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n    var la = a.length;\n    var lb = b.length;\n    while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n      la--;\n      lb--;\n    }\n    var offset = 0;\n    while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n      offset++;\n    }\n    la -= offset;\n    lb -= offset;\n    if (la === 0 || lb < 3) {\n      return lb;\n    }\n    var x = 0;\n    var y;\n    var d0;\n    var d1;\n    var d2;\n    var d3;\n    var dd;\n    var dy;\n    var ay;\n    var bx0;\n    var bx1;\n    var bx2;\n    var bx3;\n    var vector = [];\n    for (y = 0; y < la; y++) {\n      vector.push(y + 1);\n      vector.push(a.charCodeAt(offset + y));\n    }\n    var len = vector.length - 1;\n    for (; x < lb - 3;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      bx1 = b.charCodeAt(offset + (d1 = x + 1));\n      bx2 = b.charCodeAt(offset + (d2 = x + 2));\n      bx3 = b.charCodeAt(offset + (d3 = x + 3));\n      dd = x += 4;\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        ay = vector[y + 1];\n        d0 = _min(dy, d0, d1, bx0, ay);\n        d1 = _min(d0, d1, d2, bx1, ay);\n        d2 = _min(d1, d2, d3, bx2, ay);\n        dd = _min(d2, d3, dd, bx3, ay);\n        vector[y] = dd;\n        d3 = d2;\n        d2 = d1;\n        d1 = d0;\n        d0 = dy;\n      }\n    }\n    for (; x < lb;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      dd = ++x;\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n        d0 = dy;\n      }\n    }\n    return dd;\n  };\n}();\nconst MAX_MATCH_SCORE = 3;\nconst MAX_SUGGESTION_COUNT = 4;\nconst TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = jsLevenshtein(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== 'string') {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = jsLevenshtein(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref3, _ref4) => {\n    let [leftScore] = _ref3;\n    let [rightScore] = _ref4;\n    return leftScore - rightScore;\n  }).filter(_ref5 => {\n    let [score] = _ref5;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref6 => {\n    let [, handler] = _ref6;\n    return handler;\n  });\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  • ${handler.info.header}`).join('\\n')}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'warn';\n  if (typeof strategy === 'function') {\n    strategy(request);\n    return;\n  }\n  /**\r\n   * @note Ignore exceptions during GraphQL request parsing because at this point\r\n   * we cannot assume the unhandled request is a valid GraphQL request.\r\n   * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\r\n   */\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  const handlerGroups = groupHandlersByType(handlers);\n  const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n  const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n  const handlerSuggestion = suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : '';\n  const publicUrl = getPublicUrlFromRequest(request);\n  const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n  const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`].filter(Boolean);\n  const message = messageTemplate.join('\\n\\n');\n  switch (strategy) {\n    case 'error':\n      {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message);\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n      }\n    case 'warn':\n      {\n        devUtils.warn('Warning: %s', message);\n        break;\n      }\n    case 'bypass':\n      break;\n    default:\n      throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy));\n  }\n}\nfunction readResponseCookies(request, response) {\n  store.add(Object.assign(Object.assign({}, request), {\n    url: request.url.toString()\n  }), response);\n  store.persist();\n}\nfunction handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c;\n  return __awaiter(this, void 0, void 0, function* () {\n    emitter.emit('request:start', request);\n    // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n    if (request.headers.get('x-msw-bypass')) {\n      emitter.emit('request:end', request);\n      (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, request);\n      return;\n    }\n    // Resolve a mocked response from the list of request handlers.\n    const lookupResult = yield getResponse(request, handlers, handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.resolutionContext);\n    const {\n      handler,\n      response\n    } = lookupResult;\n    // When there's no handler for the request, consider it unhandled.\n    // Allow the developer to react to such cases.\n    if (!handler) {\n      onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n      emitter.emit('request:unhandled', request);\n      emitter.emit('request:end', request);\n      (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, request);\n      return;\n    }\n    // When the handled request returned no mocked response, warn the developer,\n    // as it may be an oversight on their part. Perform the request as-is.\n    if (!response) {\n      devUtils.warn(`\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`, response, handler.info.header, handler.info.callFrame);\n      emitter.emit('request:end', request);\n      (_c = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onBypassResponse) === null || _c === void 0 ? void 0 : _c.call(handleRequestOptions, request);\n      return;\n    }\n    // Store all the received response cookies in the virtual cookie store.\n    readResponseCookies(request, response);\n    emitter.emit('request:match', request);\n    return new Promise(resolve => {\n      var _a, _b, _c;\n      const requiredLookupResult = lookupResult;\n      const transformedResponse = ((_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.transformResponse) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, response)) || response;\n      (_b = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponse) === null || _b === void 0 ? void 0 : _b.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n      setTimeout(() => {\n        var _a;\n        (_a = handleRequestOptions === null || handleRequestOptions === void 0 ? void 0 : handleRequestOptions.onMockedResponseSent) === null || _a === void 0 ? void 0 : _a.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n        emitter.emit('request:end', request);\n        resolve(transformedResponse);\n      }, (_c = response.delay) !== null && _c !== void 0 ? _c : 0);\n    });\n  });\n}\nconst createRequestListener = (context, options) => {\n  return (event, message) => __awaiter(void 0, void 0, void 0, function* () {\n    const channel = createBroadcastChannel(event);\n    try {\n      const request = parseWorkerRequest(message.payload);\n      yield handleRequest(request, context.requestHandlers, options, context.emitter, {\n        transformResponse(response) {\n          return Object.assign(Object.assign({}, response), {\n            headers: response.headers.all()\n          });\n        },\n        onBypassResponse() {\n          return channel.send({\n            type: 'MOCK_NOT_FOUND'\n          });\n        },\n        onMockedResponse(response) {\n          channel.send({\n            type: 'MOCK_SUCCESS',\n            payload: response\n          });\n        },\n        onMockedResponseSent(response, _ref7) {\n          let {\n            handler,\n            publicRequest,\n            parsedRequest\n          } = _ref7;\n          if (!options.quiet) {\n            handler.log(publicRequest, response, handler, parsedRequest);\n          }\n        }\n      });\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        return channel.send({\n          type: 'NETWORK_ERROR',\n          payload: {\n            name: error.name,\n            message: error.message\n          }\n        });\n      }\n      // Treat all the other exceptions in a request handler\n      // as unintended, alerting that there is a problem needs fixing.\n      channel.send({\n        type: 'INTERNAL_ERROR',\n        payload: {\n          status: 500,\n          body: JSON.stringify({\n            errorType: error.constructor.name,\n            message: error.message,\n            location: error.stack\n          })\n        }\n      });\n    }\n  });\n};\nfunction requestIntegrityCheck(context, serviceWorker) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Signal Service Worker to report back its integrity\n    context.workerChannel.send('INTEGRITY_CHECK_REQUEST');\n    const {\n      payload: actualChecksum\n    } = yield context.events.once('INTEGRITY_CHECK_RESPONSE');\n    // Compare the response from the Service Worker and the\n    // global variable set by Rollup during the build.\n    if (actualChecksum !== \"02f4ad4a2797f85668baf196e553d929\") {\n      throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"02f4ad4a2797f85668baf196e553d929\"}).`);\n    }\n    return serviceWorker;\n  });\n}\n\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  var _this = this;\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  // Defer any `fetch` requests until the Service Worker is ready.\n  const originalFetch = window.fetch;\n  window.fetch = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return __awaiter(_this, void 0, void 0, function* () {\n      yield until(() => predicatePromise);\n      window.fetch = originalFetch;\n      return window.fetch(...args);\n    });\n  };\n}\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const {\n      payload: responseJson\n    } = message;\n    /**\r\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\r\n     * That kind of responses cannot be manipulated in JavaScript due\r\n     * to the security considerations.\r\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\r\n     * @see https://github.com/mswjs/msw/issues/529\r\n     */\n    if ((_a = responseJson.type) === null || _a === void 0 ? void 0 : _a.includes('opaque')) {\n      return;\n    }\n    const response = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw';\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId);\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId);\n    }\n  };\n}\nfunction validateWorkerScope(registration, options) {\n  if (!(options === null || options === void 0 ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(`\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`);\n  }\n}\nconst createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners();\n      // Handle requests signaled by the worker.\n      context.workerChannel.on('REQUEST', createRequestListener(context, options));\n      context.workerChannel.on('RESPONSE', createResponseListener(context));\n      const instance = yield getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions === null || customOptions === void 0 ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED');\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval);\n      });\n      // Check if the active Service Worker is the latest published one\n      const [integrityError] = yield until(() => requestIntegrityCheck(context, worker));\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `);\n      }\n      yield enableMocking(context, options).catch(err => {\n        throw new Error(`Failed to enable mocking: ${err === null || err === void 0 ? void 0 : err.message}`);\n      });\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send('KEEPALIVE_REQUEST'), 5000);\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    });\n    const workerRegistration = startWorkerInstance();\n    // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  console.log(`%c${devUtils.formatMessage('Mocking disabled.')}`, 'color:orangered;font-weight:bold;');\n}\nconst createStop = context => {\n  return function stop() {\n    var _a;\n    /**\r\n     * Signal the Service Worker to disable mocking for this client.\r\n     * Use this an an explicit way to stop the mocking, while preserving\r\n     * the worker-client relation. Does not affect the worker's lifecycle.\r\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE');\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) === null || _a === void 0 ? void 0 : _a.quiet\n    });\n  };\n};\nfunction use(currentHandlers) {\n  for (var _len3 = arguments.length, handlers = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    handlers[_key3 - 1] = arguments[_key3];\n  }\n  currentHandlers.unshift(...handlers);\n}\nfunction restoreHandlers(handlers) {\n  handlers.forEach(handler => {\n    handler.markAsSkipped(false);\n  });\n}\nfunction resetHandlers(initialHandlers) {\n  for (var _len4 = arguments.length, nextHandlers = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    nextHandlers[_key4 - 1] = arguments[_key4];\n  }\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\n}\nconst DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n/**\r\n * Returns resolved worker start options, merging the default options\r\n * with the given custom options.\r\n */\nfunction resolveStartOptions(initialOptions) {\n  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\n}\nfunction prepareStartHandler(handler, context) {\n  return initialOptions => {\n    context.startOptions = resolveStartOptions(initialOptions);\n    return handler(context.startOptions, initialOptions || {});\n  };\n}\n\n/**\r\n * Converts a given isomorphic request to a `MockedRequest` instance.\r\n */\nfunction parseIsomorphicRequest(request) {\n  const mockedRequest = {\n    id: request.id,\n    url: request.url,\n    method: request.method,\n    body: parseBody(request.body, request.headers),\n    headers: request.headers,\n    cookies: {},\n    redirect: 'manual',\n    referrer: '',\n    keepalive: false,\n    cache: 'default',\n    mode: 'cors',\n    referrerPolicy: 'no-referrer',\n    integrity: '',\n    destination: 'document',\n    bodyUsed: false,\n    credentials: 'same-origin'\n  };\n  // Set mocked request cookies from the `cookie` header of the original request.\n  // No need to take `credentials` into account, because in Node.js requests are intercepted\n  // _after_ they happen. Request issuer should have already taken care of sending relevant cookies.\n  // Unlike browser, where interception is on the worker level, _before_ the request happens.\n  const requestCookiesString = request.headers.get('cookie');\n  // Attach all the cookies from the virtual cookie store.\n  setRequestCookies(mockedRequest);\n  const requestCookies = requestCookiesString ? parse_1(requestCookiesString) : {};\n  // Merge both direct request cookies and the cookies inherited\n  // from other same-origin requests in the cookie store.\n  mockedRequest.cookies = Object.assign(Object.assign({}, mockedRequest.cookies), requestCookies);\n  return mockedRequest;\n}\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = createInterceptor({\n    modules: [interceptFetch, interceptXMLHttpRequest],\n    resolver(request) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const mockedRequest = parseIsomorphicRequest(request);\n        return handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n          transformResponse(response) {\n            return {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers.all(),\n              body: response.body\n            };\n          },\n          onMockedResponseSent(response, _ref8) {\n            let {\n              handler,\n              publicRequest,\n              parsedRequest\n            } = _ref8;\n            if (!options.quiet) {\n              handler.log(publicRequest, response, handler, parsedRequest);\n            }\n          }\n        });\n      });\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\nfunction createFallbackStart(context) {\n  return function start(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      context.fallbackInterceptor = createFallbackRequestListener(context, options);\n      printStartMessage({\n        message: 'Mocking enabled (fallback mode).',\n        quiet: options.quiet\n      });\n      return undefined;\n    });\n  };\n}\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) === null || _a === void 0 ? void 0 : _a.restore();\n    printStopMessage({\n      quiet: (_b = context.startOptions) === null || _b === void 0 ? void 0 : _b.quiet\n    });\n  };\n}\n\n/**\r\n * Pipes all emitted events from one emitter to another.\r\n */\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function (event) {\n    for (var _len5 = arguments.length, data = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      data[_key5 - 1] = arguments[_key5];\n    }\n    destination.emit(event, ...data);\n    return rawEmit.call(this, event, ...data);\n  };\n  // @ts-ignore\n  source.emit._isPiped = true;\n}\n\n// Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\nlet listeners = [];\n/**\r\n * Creates a new mock Service Worker registration\r\n * with the given request handlers.\r\n * @param {RequestHandler[]} requestHandlers List of request handlers\r\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\r\n */\nfunction setupWorker() {\n  for (var _len6 = arguments.length, requestHandlers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    requestHandlers[_key6] = arguments[_key6];\n  }\n  requestHandlers.forEach(handler => {\n    if (Array.isArray(handler)) throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\n  });\n  // Error when attempting to run this function in a Node.js environment.\n  if (lib$3.exports.isNodeProcess()) {\n    throw new Error(devUtils.formatMessage('Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.'));\n  }\n  const emitter = new lib$1.StrictEventEmitter();\n  const publicEmitter = new lib$1.StrictEventEmitter();\n  pipeEvents(emitter, publicEmitter);\n  const context = {\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, 'message', event => {\n          // Avoid messages broadcasted from unrelated workers.\n          if (event.source !== context.worker) {\n            return;\n          }\n          const message = jsonParse(event.data);\n          if (!message) {\n            return;\n          }\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n      send(type) {\n        var _a;\n        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage(type);\n      }\n    },\n    events: {\n      addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType,\n          target,\n          callback\n        });\n        return () => {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n      removeAllListeners() {\n        for (const {\n          target,\n          eventType,\n          callback\n        } of listeners) {\n          target.removeEventListener(eventType, callback);\n        }\n        listeners = [];\n      },\n      once(eventType) {\n        const bindings = [];\n        return new Promise((resolve, reject) => {\n          const handleIncomingMessage = event => {\n            try {\n              const message = JSON.parse(event.data);\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error) {\n              reject(error);\n            }\n          };\n          bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\n        }).finally(() => {\n          bindings.forEach(unbind => unbind());\n        });\n      }\n    },\n    useFallbackMode: !('serviceWorker' in navigator) || location.protocol === 'file:'\n  };\n  const startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n  const stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop() {\n      context.events.removeAllListeners();\n      context.emitter.removeAllListeners();\n      publicEmitter.removeAllListeners();\n      stopHandler();\n    },\n    use() {\n      for (var _len7 = arguments.length, handlers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        handlers[_key7] = arguments[_key7];\n      }\n      use(context.requestHandlers, ...handlers);\n    },\n    restoreHandlers() {\n      restoreHandlers(context.requestHandlers);\n    },\n    resetHandlers() {\n      for (var _len8 = arguments.length, nextHandlers = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        nextHandlers[_key8] = arguments[_key8];\n      }\n      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\n    },\n    printHandlers() {\n      context.requestHandlers.forEach(handler => {\n        const {\n          header,\n          callFrame\n        } = handler.info;\n        const pragma = handler.info.hasOwnProperty('operationType') ? '[graphql]' : '[rest]';\n        console.groupCollapsed(`${pragma} ${header}`);\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`);\n        }\n        console.log('Handler:', handler);\n        if (handler instanceof RestHandler) {\n          console.log('Match:', `https://mswjs.io/repl?path=${handler.info.path}`);\n        }\n        console.groupEnd();\n      });\n    },\n    events: {\n      on() {\n        return publicEmitter.on(...arguments);\n      },\n      removeListener() {\n        return publicEmitter.removeListener(...arguments);\n      },\n      removeAllListeners() {\n        return publicEmitter.removeAllListeners(...arguments);\n      }\n    }\n  };\n}\nexport { handleRequest, parseIsomorphicRequest, setupWorker };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}