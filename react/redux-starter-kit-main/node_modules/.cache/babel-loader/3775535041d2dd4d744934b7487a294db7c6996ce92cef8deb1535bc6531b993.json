{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nexports.Relation = exports.RelationKind = void 0;\nvar debug_1 = require(\"debug\");\nvar set_1 = __importDefault(require(\"lodash/set\"));\nvar get_1 = __importDefault(require(\"lodash/get\"));\nvar outvariant_1 = require(\"outvariant\");\nvar glossary_1 = require(\"../glossary\");\nvar executeQuery_1 = require(\"../query/executeQuery\");\nvar definePropertyAtPath_1 = require(\"../utils/definePropertyAtPath\");\nvar findPrimaryKey_1 = require(\"../utils/findPrimaryKey\");\nvar first_1 = require(\"../utils/first\");\nvar log = debug_1.debug('relation');\nvar RelationKind;\n(function (RelationKind) {\n  RelationKind[\"OneOf\"] = \"ONE_OF\";\n  RelationKind[\"ManyOf\"] = \"MANY_OF\";\n})(RelationKind = exports.RelationKind || (exports.RelationKind = {}));\nvar DEFAULT_RELATION_ATTRIBUTES = {\n  nullable: false,\n  unique: false\n};\nvar Relation = /** @class */function () {\n  function Relation(definition) {\n    this.source = null;\n    // These lazy properties are set after calling the \".apply()\" method.\n    this.dictionary = null;\n    this.db = null;\n    this.kind = definition.kind;\n    this.attributes = __assign(__assign({}, DEFAULT_RELATION_ATTRIBUTES), definition.attributes || {});\n    this.target = {\n      modelName: definition.to.toString(),\n      // @ts-expect-error Null is an intermediate value.\n      primaryKey: null\n    };\n    log('constructing a \"%s\" relation to \"%s\" with attributes: %o', this.kind, definition.to, this.attributes);\n  }\n  /**\n   * Applies the relation to the given entity.\n   * Creates a connection between the relation's target and source.\n   * Does not define the proxy property getter.\n   */\n  Relation.prototype.apply = function (entity, propertyPath, dictionary, db) {\n    this.dictionary = dictionary;\n    this.db = db;\n    var sourceModelName = entity[glossary_1.ENTITY_TYPE];\n    var sourcePrimaryKey = entity[glossary_1.PRIMARY_KEY];\n    this.source = {\n      modelName: sourceModelName,\n      propertyPath: propertyPath,\n      primaryKey: sourcePrimaryKey\n    };\n    // Get the referenced model's primary key name.\n    var targetPrimaryKey = findPrimaryKey_1.findPrimaryKey(this.dictionary[this.target.modelName]);\n    outvariant_1.invariant(targetPrimaryKey, 'Failed to create a \"%s\" relation to \"%s\": referenced model does not exist or has no primary key.', this.kind, this.target.modelName);\n    this.target.primaryKey = targetPrimaryKey;\n  };\n  /**\n   * Updates the relation references (values) to resolve the relation with.\n   */\n  Relation.prototype.resolveWith = function (entity, refs) {\n    var _a, _b;\n    var _this = this;\n    var _c, _d;\n    var exception = function (predicate, reason) {\n      var positionals = [];\n      for (var _i = 2; _i < arguments.length; _i++) {\n        positionals[_i - 2] = arguments[_i];\n      }\n      outvariant_1.invariant.apply(void 0, __spreadArray([predicate, \"Failed to resolve a \\\"%s\\\" relationship to \\\"%s\\\" at \\\"%s.%s\\\" (%s: \\\"%s\\\"): \" + reason, _this.kind, _this.target.modelName, _this.source.modelName, _this.source.propertyPath, _this.source.primaryKey, entity[_this.source.primaryKey]], __read(positionals)));\n    };\n    outvariant_1.invariant(this.source, 'Failed to resolve a \"%s\" relational property to \"%s\": relation has not been applied.', this.kind, this.target.modelName);\n    log('resolving a \"%s\" relational property to \"%s\" on \"%s.%s\" (\"%s\"):', this.kind, this.target.modelName, this.source.modelName, this.source.propertyPath, entity[this.source.primaryKey], refs);\n    log('entity of this relation:', entity);\n    // Support null as the next relation value for nullable relations.\n    if (refs === null) {\n      exception(this.attributes.nullable, 'cannot resolve a non-nullable relationship with null.');\n      log('this relation resolves with null');\n      // Override the relational property of the entity to return null.\n      this.setValueResolver(entity, function () {\n        return null;\n      });\n      return;\n    }\n    exception(this.target.primaryKey, 'referenced model has no primary key set.');\n    var referencesList = [].concat(refs);\n    var records = this.db.getModel(this.target.modelName);\n    log('records in the referenced model:', records.keys());\n    // Forbid referencing entities from a model different than the one\n    // defined in the\n    referencesList.forEach(function (ref) {\n      var refModelName = ref[glossary_1.ENTITY_TYPE];\n      var refPrimaryKey = ref[glossary_1.PRIMARY_KEY];\n      var refId = ref[_this.target.primaryKey];\n      exception(refModelName, 'expected a referenced entity to be \"%s\" but got %o', _this.target.modelName, ref);\n      exception(refModelName === _this.target.modelName, 'expected a referenced entity to be \"%s\" but got \"%s\" (%s: \"%s\").', _this.target.modelName, refModelName, refPrimaryKey, ref[refPrimaryKey]);\n      // Forbid referencing non-existing entities.\n      // This guards against assigning a compatible plain object\n      // as the relational value.\n      exception(records.has(refId), 'referenced entity \"%s\" (%s: \"%s\") does not exist.', refModelName, _this.target.primaryKey, refId);\n    });\n    // Ensure that unique relations don't reference\n    // entities that are already referenced by other entities.\n    if (this.attributes.unique) {\n      log('validating a unique \"%s\" relation to \"%s\" on \"%s.%s\"...', this.kind, this.target.modelName, this.source.modelName, this.source.propertyPath);\n      // Get the list of entities of the same entity type\n      // that reference the same relational values.\n      var extraneousEntities = executeQuery_1.executeQuery(this.source.modelName, this.source.primaryKey, {\n        where: set_1[\"default\"]((_a = {},\n        // Omit the current entity when querying\n        // the list of other entities that reference\n        // the same value.\n        _a[this.source.primaryKey] = {\n          notEquals: entity[this.source.primaryKey]\n        }, _a), this.source.propertyPath, (_b = {}, _b[this.target.primaryKey] = {\n          \"in\": referencesList.map(function (entity) {\n            return entity[_this.target.primaryKey];\n          })\n        }, _b))\n      }, this.db);\n      log('found other %s referencing the same %s:', this.source.modelName, this.target.modelName, extraneousEntities);\n      if (extraneousEntities.length > 0) {\n        var extraneousReferences_1 = extraneousEntities.flatMap(function (extraneous) {\n          var references = [].concat(get_1[\"default\"](extraneous, _this.source.propertyPath));\n          return references.map(function (entity) {\n            return entity[_this.target.primaryKey];\n          });\n        });\n        var firstInvalidReference = referencesList.find(function (entity) {\n          return extraneousReferences_1.includes(entity[_this.target.primaryKey]);\n        });\n        exception(false, 'the referenced \"%s\" (%s: \"%s\") belongs to another \"%s\" (%s: \"%s\").', this.target.modelName, this.target.primaryKey, firstInvalidReference === null || firstInvalidReference === void 0 ? void 0 : firstInvalidReference[this.target.primaryKey], this.source.modelName, (_c = extraneousEntities[0]) === null || _c === void 0 ? void 0 : _c[glossary_1.PRIMARY_KEY], (_d = extraneousEntities[0]) === null || _d === void 0 ? void 0 : _d[this.source.primaryKey]);\n      }\n    }\n    this.setValueResolver(entity, function () {\n      var queryResult = referencesList.reduce(function (result, ref) {\n        var _a;\n        return result.concat(executeQuery_1.executeQuery(_this.target.modelName, _this.target.primaryKey, {\n          where: (_a = {}, _a[_this.target.primaryKey] = {\n            equals: ref[_this.target.primaryKey]\n          }, _a)\n        }, _this.db));\n      }, []);\n      return _this.kind === RelationKind.OneOf ? first_1.first(queryResult) : queryResult;\n    });\n  };\n  Relation.prototype.setValueResolver = function (entity, resolver) {\n    var _this = this;\n    log('setting value resolver at \"%s\" on: %j', this.source.propertyPath, entity);\n    outvariant_1.invariant(entity[glossary_1.ENTITY_TYPE], 'Failed to set a value resolver on a \"%s\" relationship to \"%s\" at \"%s.%s\": provided object (%j) is not an entity.', this.kind, this.target.modelName, this.source.modelName, this.source.propertyPath.join('.'), entity);\n    definePropertyAtPath_1.definePropertyAtPath(entity, this.source.propertyPath, {\n      // Mark the property as enumerable so it gets listed\n      // when iterating over the entity's properties.\n      enumerable: true,\n      // Mark the property as configurable so it could be re-defined\n      // when updating it during the entity update (\"update\"/\"updateMany\").\n      configurable: true,\n      get: function () {\n        log('GET \"%s.%s\" on \"%s\" (\"%s\")', _this.source.modelName, _this.source.propertyPath, _this.source.modelName, entity[_this.source.primaryKey], _this);\n        var nextValue = resolver();\n        log('resolved \"%s\" relation at \"%s.%s\" (\"%s\") to:', _this.kind, _this.source.modelName, _this.source.propertyPath, entity[_this.source.primaryKey], nextValue);\n        return nextValue;\n      }\n    });\n  };\n  return Relation;\n}();\nexports.Relation = Relation;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}