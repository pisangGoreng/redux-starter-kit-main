{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interceptor = exports.InterceptorReadyState = exports.deleteGlobalSymbol = exports.getGlobalSymbol = void 0;\nvar debug_1 = require(\"debug\");\nvar AsyncEventEmitter_1 = require(\"./utils/AsyncEventEmitter\");\nvar nextTick_1 = require(\"./utils/nextTick\");\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  );\n}\nexports.getGlobalSymbol = getGlobalSymbol;\nfunction setGlobalSymbol(symbol, value) {\n  // @ts-ignore\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  // @ts-ignore\n  delete globalThis[symbol];\n}\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nvar InterceptorReadyState;\n(function (InterceptorReadyState) {\n  InterceptorReadyState[\"IDLE\"] = \"IDLE\";\n  InterceptorReadyState[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState[\"DISPOSED\"] = \"DISPOSED\";\n})(InterceptorReadyState = exports.InterceptorReadyState || (exports.InterceptorReadyState = {}));\nvar Interceptor = /** @class */function () {\n  function Interceptor(symbol) {\n    this.symbol = symbol;\n    this.readyState = InterceptorReadyState.IDLE;\n    this.emitter = new AsyncEventEmitter_1.AsyncEventEmitter();\n    this.subscriptions = [];\n    this.log = debug_1.debug(symbol.description);\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0);\n    this.log('constructing the interceptor...');\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  Interceptor.prototype.checkEnvironment = function () {\n    return true;\n  };\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  Interceptor.prototype.apply = function () {\n    var _this = this;\n    var log = this.log.extend('apply');\n    log('applying the interceptor...');\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!');\n      return;\n    }\n    var shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!');\n      return;\n    }\n    this.readyState = InterceptorReadyState.APPLYING;\n    // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n    this.emitter.activate();\n    log('activated the emiter!', this.emitter.readyState);\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    var runningInstance = this.getInstance();\n    if (runningInstance) {\n      log('found a running instance, reusing...');\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = function (event, listener) {\n        log('proxying the \"%s\" listener', event);\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener);\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        _this.subscriptions.push(function () {\n          runningInstance.emitter.removeListener(event, listener);\n          log('removed proxied \"%s\" listener!', event);\n        });\n      };\n      nextTick_1.nextTick(function () {\n        _this.readyState = InterceptorReadyState.APPLIED;\n      });\n      return;\n    }\n    log('no running instance found, setting up a new instance...');\n    // Setup the interceptor.\n    this.setup();\n    // Store the newly applied interceptor instance globally.\n    this.setInstance();\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.APPLIED;\n    });\n  };\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  Interceptor.prototype.setup = function () {};\n  /**\n   * Listen to the interceptor's public events.\n   */\n  Interceptor.prototype.on = function (event, listener) {\n    var log = this.log.extend('on');\n    if (this.readyState === InterceptorReadyState.DISPOSING || this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot listen to events, already disposed!');\n      return;\n    }\n    log('adding \"%s\" event listener:', event, listener.name);\n    this.emitter.on(event, listener);\n  };\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  Interceptor.prototype.dispose = function () {\n    var e_1, _a;\n    var _this = this;\n    var log = this.log.extend('dispose');\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!');\n      return;\n    }\n    log('disposing the interceptor...');\n    this.readyState = InterceptorReadyState.DISPOSING;\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...');\n      return;\n    }\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance();\n    log('global symbol deleted:', getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length);\n      try {\n        for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var dispose = _c.value;\n          dispose();\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      this.subscriptions = [];\n      log('disposed of all subscriptions!', this.subscriptions.length);\n    }\n    this.emitter.deactivate();\n    log('destroyed the listener!');\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.DISPOSED;\n    });\n  };\n  Interceptor.prototype.getInstance = function () {\n    var _a;\n    var instance = getGlobalSymbol(this.symbol);\n    this.log('retrieved global instance:', (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.name);\n    return instance;\n  };\n  Interceptor.prototype.setInstance = function () {\n    setGlobalSymbol(this.symbol, this);\n    this.log('set global instance!', this.symbol.description);\n  };\n  Interceptor.prototype.clearInstance = function () {\n    deleteGlobalSymbol(this.symbol);\n    this.log('cleared global instance!', this.symbol.description);\n  };\n  return Interceptor;\n}();\nexports.Interceptor = Interceptor;\n//# sourceMappingURL=Interceptor.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}