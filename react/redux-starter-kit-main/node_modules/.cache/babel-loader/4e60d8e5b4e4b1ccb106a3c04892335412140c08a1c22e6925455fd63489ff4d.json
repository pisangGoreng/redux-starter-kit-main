{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nexports.updateEntity = void 0;\nvar debug_1 = require(\"debug\");\nvar get_1 = __importDefault(require(\"lodash/get\"));\nvar set_1 = __importDefault(require(\"lodash/set\"));\nvar outvariant_1 = require(\"outvariant\");\nvar Relation_1 = require(\"../relations/Relation\");\nvar glossary_1 = require(\"../glossary\");\nvar isObject_1 = require(\"../utils/isObject\");\nvar inheritInternalProperties_1 = require(\"../utils/inheritInternalProperties\");\nvar nullable_1 = require(\"../nullable\");\nvar spread_1 = require(\"../utils/spread\");\nvar log = debug_1.debug('updateEntity');\n/**\n * Update an entity with the given next data.\n */\nfunction updateEntity(entity, data, definition) {\n  log('updating entity:\\n%j\\nwith data:\\n%j', entity, data);\n  log('model definition:', definition);\n  var nextEntity = spread_1.spread(entity);\n  inheritInternalProperties_1.inheritInternalProperties(nextEntity, entity);\n  var updateRecursively = function (data, parentPath) {\n    var e_1, _a;\n    if (parentPath === void 0) {\n      parentPath = [];\n    }\n    log('updating path \"%s\" to:', parentPath, data);\n    var _loop_1 = function (propertyName, value) {\n      var propertyPath = parentPath.concat(propertyName);\n      var prevValue = get_1[\"default\"](nextEntity, propertyPath);\n      log('previous value for \"%s\":', propertyPath, prevValue);\n      var nextValue = typeof value === 'function' ? value(prevValue, entity) : value;\n      log('next value for \"%s\":', propertyPath, nextValue);\n      var propertyDefinition = get_1[\"default\"](definition, propertyPath);\n      log('property definition for \"%s\":', propertyPath, propertyDefinition);\n      if (propertyDefinition == null) {\n        log('skipping an unknown property \"%s\" on \"%s\"...', propertyName, entity[glossary_1.ENTITY_TYPE]);\n        return \"continue\";\n      }\n      if (propertyDefinition instanceof Relation_1.Relation) {\n        log('property \"%s\" is a \"%s\" relationship to \"%s\"', propertyPath, propertyDefinition.kind, propertyDefinition.target.modelName);\n        var location_1 = nextEntity[glossary_1.ENTITY_TYPE] + \".\" + propertyPath.join('.');\n        if (nextValue == null) {\n          // Forbid updating a non-nullable relationship to null.\n          outvariant_1.invariant(propertyDefinition.attributes.nullable, 'Failed to update a \"%s\" relationship to \"%s\" at \"%s\" (%s: \"%s\"): cannot update a non-nullable relationship to null.', propertyDefinition.kind, propertyDefinition.target.modelName, location_1, nextEntity[glossary_1.PRIMARY_KEY], nextEntity[nextEntity[glossary_1.PRIMARY_KEY]]);\n          log('re-defining the \"%s\" relationship on \"%s\" to: null', propertyName, nextEntity[glossary_1.ENTITY_TYPE]);\n          propertyDefinition.resolveWith(nextEntity, null);\n          return \"continue\";\n        }\n        if (propertyDefinition.kind === Relation_1.RelationKind.ManyOf) {\n          // Forbid updating a \"MANY_OF\" relation to a non-array value.\n          outvariant_1.invariant(Array.isArray(nextValue), 'Failed to update a \"%s\" relationship to \"%s\" at \"%s\" (%s: \"%s\"): expected the next value to be an array of entities but got %j.', propertyDefinition.kind, propertyDefinition.target.modelName, location_1, nextEntity[glossary_1.PRIMARY_KEY], nextEntity[nextEntity[glossary_1.PRIMARY_KEY]], nextValue);\n          nextValue.forEach(function (ref, index) {\n            // Forbid providing a compatible plain object in any array members.\n            outvariant_1.invariant(ref[glossary_1.ENTITY_TYPE], 'Failed to update a \"%s\" relationship to \"%s\" at \"%s\" (%s: \"%s\"): expected the next value at index %d to be an entity but got %j.', propertyDefinition.kind, propertyDefinition.target.modelName, location_1, nextEntity[glossary_1.PRIMARY_KEY], nextEntity[nextEntity[glossary_1.PRIMARY_KEY]], index, ref);\n            // Forbid referencing a different model in any array members.\n            outvariant_1.invariant(ref[glossary_1.ENTITY_TYPE] === propertyDefinition.target.modelName, 'Failed to update a \"%s\" relationship to \"%s\" at \"%s\" (%s: \"%s\"): expected the next value at index %d to reference a \"%s\" but got \"%s\".', propertyDefinition.kind, propertyDefinition.target.modelName, location_1, nextEntity[glossary_1.PRIMARY_KEY], nextEntity[nextEntity[glossary_1.PRIMARY_KEY]], index, propertyDefinition.target.modelName, ref[glossary_1.ENTITY_TYPE]);\n          });\n          propertyDefinition.resolveWith(nextEntity, nextValue);\n          return \"continue\";\n        }\n        // Forbid updating a relationship with a compatible plain object.\n        outvariant_1.invariant(nextValue[glossary_1.ENTITY_TYPE], 'Failed to update a \"%s\" relationship to \"%s\" at \"%s\" (%s: \"%s\"): expected the next value to be an entity but got %j.', propertyDefinition.kind, propertyDefinition.target.modelName, location_1, nextEntity[glossary_1.PRIMARY_KEY], nextEntity[nextEntity[glossary_1.PRIMARY_KEY]], nextValue);\n        // Forbid updating a relationship to an entity of a different model.\n        outvariant_1.invariant(nextValue[glossary_1.ENTITY_TYPE] == propertyDefinition.target.modelName, 'Failed to update a \"%s\" relationship to \"%s\" at \"%s\" (%s: \"%s\"): expected the next value to reference a \"%s\" but got \"%s\" (%s: \"%s\").', propertyDefinition.kind, propertyDefinition.target.modelName, location_1, nextEntity[glossary_1.PRIMARY_KEY], nextEntity[nextEntity[glossary_1.PRIMARY_KEY]], propertyDefinition.target.modelName, nextValue[glossary_1.ENTITY_TYPE], nextValue[glossary_1.PRIMARY_KEY], nextValue[nextValue[glossary_1.PRIMARY_KEY]]);\n        // Re-define the relationship only if its next value references a different entity\n        // than before. That means a new compatible entity was created as the next value.\n        if ((prevValue === null || prevValue === void 0 ? void 0 : prevValue[prevValue === null || prevValue === void 0 ? void 0 : prevValue[glossary_1.PRIMARY_KEY]]) !== nextValue[nextValue[glossary_1.PRIMARY_KEY]]) {\n          log('next referenced \"%s\" (%s: \"%s\") differs from the previous (%s: \"%s\"), re-defining the relationship...', propertyDefinition.target.modelName, nextValue[glossary_1.PRIMARY_KEY]);\n          propertyDefinition.resolveWith(nextEntity, nextValue);\n        }\n        return \"continue\";\n      }\n      // Support updating nested objects.\n      if (isObject_1.isObject(nextValue)) {\n        log('next value at \"%s\" is an object: %j, recursively updating...', propertyPath, nextValue);\n        updateRecursively(nextValue, propertyPath);\n        return \"continue\";\n      }\n      outvariant_1.invariant(nextValue !== null || propertyDefinition instanceof nullable_1.NullableProperty, 'Failed to update \"%s\" on \"%s\": cannot set a non-nullable property to null.', propertyName, entity[glossary_1.ENTITY_TYPE]);\n      log('updating a plain property \"%s\" to:', propertyPath, nextValue);\n      set_1[\"default\"](nextEntity, propertyPath, nextValue);\n    };\n    try {\n      for (var _b = __values(Object.entries(data)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          propertyName = _d[0],\n          value = _d[1];\n        _loop_1(propertyName, value);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  updateRecursively(data);\n  log('successfully updated to:', nextEntity);\n  return nextEntity;\n}\nexports.updateEntity = updateEntity;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}