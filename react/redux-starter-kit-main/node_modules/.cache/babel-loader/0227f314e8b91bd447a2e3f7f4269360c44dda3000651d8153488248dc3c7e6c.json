{"ast":null,"code":"var conventions = require(\"./conventions\");\nvar dom = require('./dom');\nvar entities = require('./entities');\nvar sax = require('./sax');\nvar DOMImplementation = dom.DOMImplementation;\nvar NAMESPACE = conventions.NAMESPACE;\nvar ParseError = sax.ParseError;\nvar XMLReader = sax.XMLReader;\n\n/**\n * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:\n *\n * > XML parsed entities are often stored in computer files which,\n * > for editing convenience, are organized into lines.\n * > These lines are typically separated by some combination\n * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n * >\n * > To simplify the tasks of applications, the XML processor must behave\n * > as if it normalized all line breaks in external parsed entities (including the document entity)\n * > on input, before parsing, by translating all of the following to a single #xA character:\n * >\n * > 1. the two-character sequence #xD #xA\n * > 2. the two-character sequence #xD #x85\n * > 3. the single character #x85\n * > 4. the single character #x2028\n * > 5. any #xD character that is not immediately followed by #xA or #x85.\n *\n * @param {string} input\n * @returns {string}\n */\nfunction normalizeLineEndings(input) {\n  return input.replace(/\\r[\\n\\u0085]/g, '\\n').replace(/[\\r\\u0085\\u2028]/g, '\\n');\n}\n\n/**\n * @typedef Locator\n * @property {number} [columnNumber]\n * @property {number} [lineNumber]\n */\n\n/**\n * @typedef DOMParserOptions\n * @property {DOMHandler} [domBuilder]\n * @property {Function} [errorHandler]\n * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing\n * \t\t\t\t\t\tdefaults to `normalizeLineEndings`\n * @property {Locator} [locator]\n * @property {Record<string, string>} [xmlns]\n *\n * @see normalizeLineEndings\n */\n\n/**\n * The DOMParser interface provides the ability to parse XML or HTML source code\n * from a string into a DOM `Document`.\n *\n * _xmldom is different from the spec in that it allows an `options` parameter,\n * to override the default behavior._\n *\n * @param {DOMParserOptions} [options]\n * @constructor\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n */\nfunction DOMParser(options) {\n  this.options = options || {\n    locator: {}\n  };\n}\nDOMParser.prototype.parseFromString = function (source, mimeType) {\n  var options = this.options;\n  var sax = new XMLReader();\n  var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\n  var errorHandler = options.errorHandler;\n  var locator = options.locator;\n  var defaultNSMap = options.xmlns || {};\n  var isHTML = /\\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;\n  var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;\n  if (locator) {\n    domBuilder.setDocumentLocator(locator);\n  }\n  sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\n  sax.domBuilder = options.domBuilder || domBuilder;\n  if (isHTML) {\n    defaultNSMap[''] = NAMESPACE.HTML;\n  }\n  defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n  var normalize = options.normalizeLineEndings || normalizeLineEndings;\n  if (source && typeof source === 'string') {\n    sax.parse(normalize(source), defaultNSMap, entityMap);\n  } else {\n    sax.errorHandler.error('invalid doc source');\n  }\n  return domBuilder.doc;\n};\nfunction buildErrorHandler(errorImpl, domBuilder, locator) {\n  if (!errorImpl) {\n    if (domBuilder instanceof DOMHandler) {\n      return domBuilder;\n    }\n    errorImpl = domBuilder;\n  }\n  var errorHandler = {};\n  var isCallback = errorImpl instanceof Function;\n  locator = locator || {};\n  function build(key) {\n    var fn = errorImpl[key];\n    if (!fn && isCallback) {\n      fn = errorImpl.length == 2 ? function (msg) {\n        errorImpl(key, msg);\n      } : errorImpl;\n    }\n    errorHandler[key] = fn && function (msg) {\n      fn('[xmldom ' + key + ']\\t' + msg + _locator(locator));\n    } || function () {};\n  }\n  build('warning');\n  build('error');\n  build('fatalError');\n  return errorHandler;\n}\n\n//console.log('#\\n\\n\\n\\n\\n\\n\\n####')\n/**\n * +ContentHandler+ErrorHandler\n * +LexicalHandler+EntityResolver2\n * -DeclHandler-DTDHandler\n *\n * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\n * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\n * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\n */\nfunction DOMHandler() {\n  this.cdata = false;\n}\nfunction position(locator, node) {\n  node.lineNumber = locator.lineNumber;\n  node.columnNumber = locator.columnNumber;\n}\n/**\n * @see org.xml.sax.ContentHandler#startDocument\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n */\nDOMHandler.prototype = {\n  startDocument: function () {\n    this.doc = new DOMImplementation().createDocument(null, null, null);\n    if (this.locator) {\n      this.doc.documentURI = this.locator.systemId;\n    }\n  },\n  startElement: function (namespaceURI, localName, qName, attrs) {\n    var doc = this.doc;\n    var el = doc.createElementNS(namespaceURI, qName || localName);\n    var len = attrs.length;\n    appendElement(this, el);\n    this.currentElement = el;\n    this.locator && position(this.locator, el);\n    for (var i = 0; i < len; i++) {\n      var namespaceURI = attrs.getURI(i);\n      var value = attrs.getValue(i);\n      var qName = attrs.getQName(i);\n      var attr = doc.createAttributeNS(namespaceURI, qName);\n      this.locator && position(attrs.getLocator(i), attr);\n      attr.value = attr.nodeValue = value;\n      el.setAttributeNode(attr);\n    }\n  },\n  endElement: function (namespaceURI, localName, qName) {\n    var current = this.currentElement;\n    var tagName = current.tagName;\n    this.currentElement = current.parentNode;\n  },\n  startPrefixMapping: function (prefix, uri) {},\n  endPrefixMapping: function (prefix) {},\n  processingInstruction: function (target, data) {\n    var ins = this.doc.createProcessingInstruction(target, data);\n    this.locator && position(this.locator, ins);\n    appendElement(this, ins);\n  },\n  ignorableWhitespace: function (ch, start, length) {},\n  characters: function (chars, start, length) {\n    chars = _toString.apply(this, arguments);\n    //console.log(chars)\n    if (chars) {\n      if (this.cdata) {\n        var charNode = this.doc.createCDATASection(chars);\n      } else {\n        var charNode = this.doc.createTextNode(chars);\n      }\n      if (this.currentElement) {\n        this.currentElement.appendChild(charNode);\n      } else if (/^\\s*$/.test(chars)) {\n        this.doc.appendChild(charNode);\n        //process xml\n      }\n\n      this.locator && position(this.locator, charNode);\n    }\n  },\n  skippedEntity: function (name) {},\n  endDocument: function () {\n    this.doc.normalize();\n  },\n  setDocumentLocator: function (locator) {\n    if (this.locator = locator) {\n      // && !('lineNumber' in locator)){\n      locator.lineNumber = 0;\n    }\n  },\n  //LexicalHandler\n  comment: function (chars, start, length) {\n    chars = _toString.apply(this, arguments);\n    var comm = this.doc.createComment(chars);\n    this.locator && position(this.locator, comm);\n    appendElement(this, comm);\n  },\n  startCDATA: function () {\n    //used in characters() methods\n    this.cdata = true;\n  },\n  endCDATA: function () {\n    this.cdata = false;\n  },\n  startDTD: function (name, publicId, systemId) {\n    var impl = this.doc.implementation;\n    if (impl && impl.createDocumentType) {\n      var dt = impl.createDocumentType(name, publicId, systemId);\n      this.locator && position(this.locator, dt);\n      appendElement(this, dt);\n      this.doc.doctype = dt;\n    }\n  },\n  /**\n   * @see org.xml.sax.ErrorHandler\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n   */\n  warning: function (error) {\n    console.warn('[xmldom warning]\\t' + error, _locator(this.locator));\n  },\n  error: function (error) {\n    console.error('[xmldom error]\\t' + error, _locator(this.locator));\n  },\n  fatalError: function (error) {\n    throw new ParseError(error, this.locator);\n  }\n};\nfunction _locator(l) {\n  if (l) {\n    return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n  }\n}\nfunction _toString(chars, start, length) {\n  if (typeof chars == 'string') {\n    return chars.substr(start, length);\n  } else {\n    //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n    if (chars.length >= start + length || start) {\n      return new java.lang.String(chars, start, length) + '';\n    }\n    return chars;\n  }\n}\n\n/*\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n * used method of org.xml.sax.ext.LexicalHandler:\n *  #comment(chars, start, length)\n *  #startCDATA()\n *  #endCDATA()\n *  #startDTD(name, publicId, systemId)\n *\n *\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\n *  #endDTD()\n *  #startEntity(name)\n *  #endEntity(name)\n *\n *\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n * IGNORED method of org.xml.sax.ext.DeclHandler\n * \t#attributeDecl(eName, aName, type, mode, value)\n *  #elementDecl(name, model)\n *  #externalEntityDecl(name, publicId, systemId)\n *  #internalEntityDecl(name, value)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n * IGNORED method of org.xml.sax.EntityResolver2\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n *  #resolveEntity(publicId, systemId)\n *  #getExternalSubset(name, baseURI)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n * IGNORED method of org.xml.sax.DTDHandler\n *  #notationDecl(name, publicId, systemId) {};\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n */\n\"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\n  DOMHandler.prototype[key] = function () {\n    return null;\n  };\n});\n\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\nfunction appendElement(hander, node) {\n  if (!hander.currentElement) {\n    hander.doc.appendChild(node);\n  } else {\n    hander.currentElement.appendChild(node);\n  }\n} //appendChild and setAttributeNS are preformance key\n\nexports.__DOMHandler = DOMHandler;\nexports.normalizeLineEndings = normalizeLineEndings;\nexports.DOMParser = DOMParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}