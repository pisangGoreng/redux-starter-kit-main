{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nexports.__esModule = true;\nexports.compileQuery = void 0;\nvar debug_1 = require(\"debug\");\nvar outvariant_1 = require(\"outvariant\");\nvar getComparatorsForValue_1 = require(\"./getComparatorsForValue\");\nvar isObject_1 = require(\"../utils/isObject\");\nvar log = debug_1.debug('compileQuery');\n/**\n * Compile a query expression into a function that accepts an actual entity\n * and returns a query execution result (whether the entity satisfies the query).\n */\nfunction compileQuery(query) {\n  log('%j', query);\n  return function (data) {\n    return Object.entries(query.where).map(function (_a) {\n      var _b = __read(_a, 2),\n        property = _b[0],\n        queryChunk = _b[1];\n      var actualValue = data[property];\n      log('executing query chunk on \"%s\":\\n\\n%j\\n\\non data:\\n\\n%j\\n', property, queryChunk, data);\n      log('actual value for \"%s\":', property, actualValue);\n      if (!queryChunk) {\n        return true;\n      }\n      // If an entity doesn't have any value for the property\n      // is being queried for, treat it as non-matching.\n      if (actualValue == null) {\n        return false;\n      }\n      return Object.entries(queryChunk).reduce(function (acc, _a) {\n        var _b = __read(_a, 2),\n          comparatorName = _b[0],\n          expectedValue = _b[1];\n        if (!acc) {\n          return acc;\n        }\n        if (Array.isArray(actualValue)) {\n          log('actual value is array, checking if at least one item matches...', {\n            comparatorName: comparatorName,\n            expectedValue: expectedValue\n          });\n          /**\n           * @fixme Can assume `some`? Why not `every`?\n           */\n          return actualValue.some(function (value) {\n            return compileQuery({\n              where: queryChunk\n            })(value);\n          });\n        }\n        // When the actual value is a resolved relational property reference,\n        // execute the current query chunk on the referenced entity.\n        if (actualValue.__type || isObject_1.isObject(actualValue)) {\n          return compileQuery({\n            where: queryChunk\n          })(actualValue);\n        }\n        var comparatorSet = getComparatorsForValue_1.getComparatorsForValue(actualValue);\n        log('comparators', comparatorSet);\n        var comparatorFn = comparatorSet[comparatorName];\n        log('using comparator function for \"%s\":', comparatorName, comparatorFn);\n        outvariant_1.invariant(comparatorFn, 'Failed to compile the query \"%j\": no comparator found for the chunk \"%s\". Please check the validity of the query.', query, comparatorName);\n        return comparatorFn(expectedValue, actualValue);\n      }, true);\n    }).every(Boolean);\n  };\n}\nexports.compileQuery = compileQuery;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}